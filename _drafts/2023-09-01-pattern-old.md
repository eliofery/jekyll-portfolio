---
layout: post
title: Паттерны и алгоритмы для работы с двумерными циклами
date: 2023-09-02 09:16 +0600
description: Рассмотрим различные варианты манипуляции с двумерными циклами. Полученные знания в дальнейшем пригодятся для решения различных типов задач, например обход двухмерной матрицы и прочее.
image: cover.jpg
alt: Паттерны для работы с двумерными циклами
category: dsa
tags: [циклы, узоры]
source:
published: false
sitemap: true
excerpt_separator: "<!--more-->"
---

{{ page.description }}

<!--more-->

## <span class="attention">Оглавление</span> статьи

1. [Вводная часть](#intro)
2. [Паттерн 1 (простой квадрат)](#pattern-1)
3. [Паттерн 2 (лесенка вправо)](#pattern-2)
4. [Паттерн 3 (перевернутая лесенка вправо)](#pattern-3)
5. [Паттерн 4 (числовая лесенка вправо)](#pattern-4)
6. [Паттерн 5 (перевернутая числовая лесенка вправо)](#pattern-5)
7. [Паттерн 6 (числовая лесенка вправо, другая вариация)](#pattern-6)
8. [Паттерн 7 (елочка)](#pattern-7)
9. [Паттерн 8 (перевернутая елочка)](#pattern-8)
10. [Паттерн 9 (почти ромб)](#pattern-9)
11. [Паттерн 10 (стрелка вправо)](#pattern-10)
12. [Паттерн 11 (бинарный треугольник вправо)](#pattern-11)
13. [Паттерн 12 (две треугольные башни)](#pattern-12)
14. [Паттерн 13 (нарастающий числовой треугольник)](#pattern-13)
15. [Паттерн 14 (нарастающий буквенный треугольник)](#pattern-14)
16. [Паттерн 15 (обратный нарастающий буквенный треугольник)](#pattern-15)
17. [Паттерн 16 (буквенный треугольник вариант 2)](#pattern-16)
18. [Паттерн 17 (буквенный равносторонний треугольник)](#pattern-17)
19. [Паттерн 18 (развернутый буквенный треугольник)](#pattern-18)
20. [Паттерн 19 (внутренний ромб)](#pattern-19)
21. [Паттерн 20 (бабочка)](#pattern-20)
22. [Паттерн 21 (прозрачный квадрат)](#pattern-21)
23. [Паттерн 22 (уменьшающаяся матрица)](#pattern-22)

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

У двумерного цикла имеется внешний циклы и внутренний цикл. Внешний цикл отвечает за строки, а внутренний цикл отвечает за столбцы.

<pre>
    с т о л б цы
с   * * * * * *
т   * * * * * *
р   * * * * * *
о   * * * * * *
ки  * * * * * *
</pre>

### Этапы оценки шаблона

1. Для внешнего цикла посчитать количество строк
2. Для внутреннего цикла посчитать количество столбцов и определенным образом соединить их со строками
3. Выводить данные во внутреннем цикле
4. Соблюдать симметрию при необходимости

{% capture code %}
// 1.
// внешний цикл обрабатывает строки
// каждая итерация внешнего цикла ждет полного завершения внутреннего цикла
// и только после этого переходит к следующей итерации строки
for (let i = 0; i < n; i++) {

  // 2.
  // внутренний цикл обрабатывает столбцы один за другим пока число столбцов не будет
  // соответствовать условию завершения внутреннего цикла
  for (let j = 0; j < n; j++) {

    // 3.
    // Вывод данных
  }

  // 4.
  // итерация внешнего цикла завершилась
  // переводим каретку (курсор) на новую строку и повторяем одну строку за другой
  // пока число строк не будет соотвествовать условию завершения внешнего цикла
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-1"><span class="attention">Паттерн</span> первый (простой квадрат)</h2>

<pre>
******
******
******
******
******
</pre>

Простой квадрат выводит одинаковое количество строк и столбцов. Выведем пять звездочек по горизонтали (строки) и по вертикали (столбцы).

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

    // внутренний цикл выводит столбцы
    // так как нужно 5 столбцов, то выводятся столбцы от 0 до 5.
    for (let j = 0; j < n; j++) {
      result += '*'
    }

    // итерация внешнего цикла завершилась
    // переводим каретку (курсор) на новую строку
    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-2"><span class="attention">Паттерн</span> второй (лесенка вправо)</h2>

<pre>
*
**
***
****
*****
</pre>

Лесенка вправо выводит заданное количество строк, а количество столбцов равно количеству итерации внешнего цикла. То есть если происходит первая итерация внешнего цикла то выведется один столбец во внутреннем цикле, при второй итерации внешнего цикла выведутся два столбца и т.д.

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

      // внутренний цикл выводит столбцы
      // так как нужно, чтобы число столбцов было не больше чем порядковый номер итерации, то
      // отобразим это следующим образом
      for (let j = 0; j <= i; j++) {
        result += '*'
      }

      // итерация внешнего цикла завершилась
      // переводим каретку (курсор) на новую строку
      result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

Обратим внимание, что для внутреннего цикла условием выхода из цикла является **j <= i**, это означает что число итераций внутреннего цикла не будет превышать текущий порядковый номер итерации внешнего цикла.

<h2 id="pattern-3"><span class="attention">Паттерн</span> третий (перевернутая лесенка вправо)</h2>

<pre>
*****
****
***
**
*
</pre>

### Вариант первый

Перевернутая лесенка вправо выводится похожим образом, только теперь итерацию внешнего цикла нужно начинать не с 0, а с заданного количества в данном случае с 5, постепенно уменьшая это число на 1 до 0. И того при первой итерации выведется 5 звездочек, потом число 5 уменьшится на 1 и выведутся 4 звезды и так далее.

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 5 до 0
  // из-за того что внутренний цикл должен рисовать звездочки от 5 постепенно уменьшая их
  // то нужно чтобы внешний цикл стартовать со значения 5, т.е. в порядке убывания
  for (let i = n; i > 0; i--) {

        // внутренний цикл выводит столбцы
        // так как нужно, чтобы число столбцов было не больше чем порядковый номер итерации, то
        // отобразим это следующим образом
        for (let j = 0; j < i; j++) {
          result += '*'
        }

        // итерация внешнего цикла завершилась
        // переводим каретку (курсор) на новую строку
        result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

### Вариант второй

Так же данный паттерн можно вывести иным способом не прибегая к обратному порядку внешнего цикла. Для этого в условии завершения внутреннего цикла нужно задать разность между общим количеством звезд, в данном случае 5 и номером текущей итерацией внешнего цикла. Т.е. при первой итерации внешнего цикла его номер будет равен 0, отнимаем от общего числа 5 этот 0, получится 5 - 0 = 5 выведутся 5 звезд. При следующей итерации внешнего цикла его номер будет равен 1, 5 - 1 = 4, выведутся 4 звезды и так далее.

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

        // внутренний цикл выводит столбцы
        // так как нужно, чтобы число столбцов было не больше чем разность общего количесва звезд
        // и порядкового номер внешней итерации, то отобразим это следующим образом
        for (let j = 0; j < n - i; j++) {
          result += '*'
        }

        // итерация внешнего цикла завершилась
        // переводим каретку (курсор) на новую строку
        result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-4"><span class="attention">Паттерн</span> четвертый (числовая лесенка вправо)</h2>

<pre>
1
12
123
1234
12345
</pre>

Данный паттерн схож с аналогичной разобранной ранее лесенкой. За исключением того что внутренний цикл должен выводить цифры в порядке возрастания вместо звезд. Так как счет начинается с 1, то внутренний цикл так же будет начинаться у нас с 1. Какое же условие завершения внутреннего цикла должно быть, чтобы соответствовать шаблону.

Здесь прослеживается закономерность того что количество столбцов равно сумме номера внешнего цикла с 1. Т.е. при первой итерации ограничения для внутреннего цикла должно быть 0 + 1 = 1, для второй итерации 1 + 1 = 2 и т.д. При это получается что внутренний цикл движется от 1 до i + 1 включительно. Взглянем на пример для большего понимания.

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

    // внутренний цикл выводит столбцы
    // так как нужно, чтобы число столбцов было не больше чем номер текущей внешней итерации + 1,
    // то отобразим это следующим образом
    for (let j = 1; j <= i + 1; j++) {
      result += `${j}`
    }

    // итерация внешнего цикла завершилась
    // переводим каретку (курсор) на новую строку
    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-5"><span class="attention">Паттерн</span> пятый (перевернутая числовая лесенка вправо)</h2>

<pre>
12345
1234
123
12
1
</pre>

Так же имеется несколько вариантов решения данного паттерна.

### Вариант первый

С проходом по внешнему циклу в порядке убывания.

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // отсчет начинается в обратном порядке от 5 до 0
  for (let i = n; i > 0; i--) {

    // внутренний цикл выводит столбцы
    // так как нужно, чтобы число столбцов было не больше чем номер текущей внешней итерации + 1,
    // то отобразим это следующим образом
    for (let j = 1; j < i + 1; j++) {
      result += `${j}`
    }

    // итерация внешнего цикла завершилась
    // переводим каретку (курсор) на новую строку
    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

### Вариант второй

В данном примере формула для внутреннего цикла будет **n - i + 1**. При данной формуле внутренний цикл будет проходить от 1 до **n - i + 1** не включая результат от этой формулы.

<pre>
Первая итерация:    5 - 0 + 1 = 6 | вывести числа с 1 до 6 | 1 2 3 4 5
Вторая итерация:    5 - 1 + 1 = 5 | вывести числа с 1 до 5 | 1 2 3 4
Третья итерация:    5 - 2 + 1 = 4 | вывести числа с 1 до 4 | 1 2 3
Четвертая итерация: 5 - 3 + 1 = 3 | вывести числа с 1 до 3 | 1 2
Пятая итерация:     5 - 4 + 1 = 2 | вывести числа с 1 до 2 | 1
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

      // внутренний цикл выводит столбцы
      // так как нужно, чтобы число столбцов было не больше общее количество минус номер текущей внешней итерации + 1,
      // то отобразим это следующим образом
      for (let j = 1; j < n - i + 1; j++) {
        result += `${j}`
      }

      // итерация внешнего цикла завершилась
      // переводим каретку (курсор) на новую строку
      result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

### Вариант третий

В данном примере формула для внутреннего цикла будет **n - i**. При данной формуле внутренний цикл будет проходить от 1 до **n - i** включая результат от этой формулы.

<pre>
Первая итерация:    5 - 0 = 5 | вывести числа с 1 до 5 | 1 2 3 4 5
Вторая итерация:    5 - 1 = 4 | вывести числа с 1 до 4 | 1 2 3 4
Третья итерация:    5 - 2 = 3 | вывести числа с 1 до 3 | 1 2 3
Четвертая итерация: 5 - 3 = 2 | вывести числа с 1 до 2 | 1 2
Пятая итерация:     5 - 4 = 1 | вывести числа с 1 до 1 | 1
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

      // внутренний цикл выводит столбцы
      // так как нужно, чтобы число столбцов было не больше общее количество мину номер текущей внешней итерации,
      // то отобразим это следующим образом
      for (let j = 1; j <= n - i; j++) {
        result += `${j}`
      }

      // итерация внешнего цикла завершилась
      // переводим каретку (курсор) на новую строку
      result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-6"><span class="attention">Паттерн</span> шестой (числовая лесенка вправо, другая вариация)</h2>

<pre>
1
22
333
4444
55555
</pre>

Глядя на этот шаблон можно заметить, что каждый столбец имеет номер итерации внешнего цикла, именно этот номер будем выводить во внутреннем цикле. Нам нужно вывести 5 строк значит внешний цикл будет идти от 1 до 5 включительно, а внутренний цикл так как не участвует в выводе, может начинаться как с 0, так и с 1, главное задать ему ограничение до номера текущей операции внешнего цикла. Рассмотрим код.

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 1 до 5 включительно.
  for (let i = 1; i <= n; i++) {

      // внутренний цикл выводит столбцы
      // так как нужно, чтобы число столбцов было не больше чем номер текущей внешней итерации,
      // то отобразим это следующим образом
      for (let j = 0; j < i; j++) {
        result += `${i}`
      }

      // итерация внешнего цикла завершилась
      // переводим каретку (курсор) на новую строку
      result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

Здесь следует обратить внимание, что в этот раз выводится значение внешнего цикла **i**, а не **j** как это было раннее.

<h2 id="pattern-7"><span class="attention">Паттерн</span> седьмой (елочка)</h2>

<pre>
    *
   ***
  *****
 *******
*********
</pre>

Посчитаем количество строк у данного шаблона их 5. Посчитаем количество столбцов их 9. Так как мы выводим символ, а не число то начало внешнего и внутреннего цикла может начинаться от 0. Определим ограничение для циклов. Для внешнего цикла от 0 до 5. Для внутреннего цикла от 0 до n * 2 - 1, то есть 5 * 2 - 1 = 9 количество столбцов.

Нужно условие во внутреннем цикле которое бы определяло когда выводить пробел, а когда звездочку. Если посчитать количество пробелов при первой итерации до первой звезды получится 4, так же количество пробелов после звезды равно 4.

То есть пока итерация внутреннего цикла меньше 4 нужно выводить пробел и если итерация внутреннего цикла больше 4 так же выводим пробел. Чтобы получить нужную 4 воспользуемся условием **j < n - i - 1** до 4, и условием **j > n + i - 1** после 4.

<pre>
Первая итерация:    5 - 0 - 1 = 4 пробела | 5 + 0 - 1 = после 4 позиции пробелы |     *
Вторая итерация:    5 - 1 - 1 = 3 пробела | 5 + 1 - 1 = после 5 позиции пробелы |    ***
Третья итерация:    5 - 2 - 1 = 2 пробела | 5 + 2 - 1 = после 6 позиции пробелы |   *****
Четвертая итерация: 5 - 3 - 1 = 1 пробела | 5 + 3 - 1 = после 7 позиции пробелы |  *******
Пятая итерация:     5 - 4 - 1 = 0 пробела | 5 + 4 - 1 = после 8 позиции пробелы | *********
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

      // внутренний цикл выводит столбцы
      // так как нужно, чтобы число столбцов было больше в 2 раза за вычитом одной позиции то выводим,
      // от 0 до n * 2 - 1, то отобразим это следующим образом
      for (let j = 0; j < n * 2 - 1; j++) {

        // условие при котором выводятся пробелы
        if (j < n - i - 1 || j > n + i - 1) {
          result += ' '
        } else {
          result += '*'
        }

      }

      // итерация внешнего цикла завершилась
      // переводим каретку (курсор) на новую строку
      result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-8"><span class="attention">Паттерн</span> восьмой (перевернутая елочка)</h2>

<pre>
*********
 *******
  *****
   ***
    *
</pre>

Логика итерации внешнего и внутреннего цикла остается прежней, необходимо лишь изменить логику условия при котором выводится пробел и звездочка.

Так как оба цикла стартуют с 0, то при первой итерации i = j то есть 0 = 0, при второй итерации i > j, то есть 1 > 0. Можно заметить, что когда итерация внешнего цикла больше итерации внутреннего цикла выводится пробел, а когда итерация внутреннего цикла больше внешнего выводится звездочка. Мы нашли закономерность для левой стороны, поищем ее для правой.

Общее количество столбцов у нас равно n * 2 - 1, при первой итерации мы выводим все столбцы, при второй итерации все столбцы минус 1, если посмотреть на порядковый номер итерации внутреннего цикла он как раз будет равен 1. И того мы нашли формулу для правой части n * 2 - 1 - i.

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

      // внутренний цикл выводит столбцы
      // так как нужно, чтобы число столбцов было больше в 2 раза за вычитом одной позиции то выводим,
      // от 0 до n * 2 - 1, то отобразим это следующим образом
      for (let j = 0; j < n * 2 - 1; j++) {

        // условие при котором выводятся пробелы
        if (i <= j && j < n * 2 - 1 - i) {
          result += '*'
        } else {
          result += ' '
        }

      }

      // итерация внешнего цикла завершилась
      // переводим каретку (курсор) на новую строку
      result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-9"><span class="attention">Паттерн</span> девять (почти ромб)</h2>

<pre>
    *
   ***
  *****
 *******
*********
*********
 *******
  *****
   ***
    *
</pre>

Данная фигура похожа на паттерн 7 и 8 как если бы мы их соединили вместе. Давай те так и поступим.

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

      // внутренний цикл выводит столбцы
      // так как нужно, чтобы число столбцов было больше в 2 раза за вычитом одной позиции то выводим,
      // от 0 до n * 2 - 1, то отобразим это следующим образом
      for (let j = 0; j < n * 2 - 1; j++) {

        // условие при котором выводятся пробелы
        if (j < n - i - 1 || j > n + i - 1) {
          result += ' '
        } else {
          result += '*'
        }

      }

      // итерация внешнего цикла завершилась
      // переводим каретку (курсор) на новую строку
      result += '\n'
  }

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

      // внутренний цикл выводит столбцы
      // так как нужно, чтобы число столбцов было больше в 2 раза за вычитом одной позиции то выводим,
      // от 0 до n * 2 - 1, то отобразим это следующим образом
      for (let j = 0; j < n * 2 - 1; j++) {

        // условие при котором выводятся пробелы
        if (i <= j && j < n * 2 - 1 - i) {
          result += '*'
        } else {
          result += ' '
        }

      }

      // итерация внешнего цикла завершилась
      // переводим каретку (курсор) на новую строку
      result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-10"><span class="attention">Паттерн</span> десять (стрелка вправо)</h2>

<pre>
*
**
***
****
*****
****
***
**
*
</pre>

Данный паттерн содержит фигуру которую мы рисовали в паттерне 2 и 3. Но здесь мы не можем взять эти два паттерна и соединить их в один как это было сделано в паттерне 9. Так как здесь нижняя часть отличается от паттерна 3.

В данном паттерне после 5 строки происходит перелом итерации в обратную сторону. Возьмем как за основу 5 строк, но так как у нас с общей сложности строк 9, то увеличим внешний цикл до n * 2 - 1.

Для внутреннего цикла зададим ограничение не более внешней итерации j < i. При такой логике у нас должна получиться следующая фигура.

<pre>
*
**
***
****
*****
******
*******
********
*********
</pre>

Как же развернуть после 5 строки внутренний цикл в обратную сторону. Мы уже проходили формулу при которой при каждой итерации отнимается одна позиция с конца, это **n - i**. Воспользуемся ей, для того чтобы развернуть вывод звездочек.

Для этого во внешнем цикле до вызова внутреннего цикла создадим дополнительную переменную **col** к которой присвоем номер текущей итерации внешнего цикла **col = i**. И по условию когда текущая итерация внешнего цикла больше общего количества элементов **i > n**, в нашем случае **i > 5**, будем разворачивать вывод данных в обратную сторону **n * 2 - i**.

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = ''

  // внешний цикл выводит строки
  // увеличиваем количество строк в два раза
  // не включая последний вариант, то есть от 0 до 9
  for (let i = 0; i < n * 2; i++) {
    let col = i

    // условие при котором будет происходить разворот вывода
    if (i > n) {
      col = n * 2 - i
    }

    // внутренний цикл выводит столбцы
    // количество столбцов не должно превышать номер текущей итерации
    for (let j = 0; j < col; j++) {
      result += '*'
    }

    // итерация внешнего цикла завершилась
    // переводим каретку (курсор) на новую строку
    result += '\n'
  }

  return result
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

Обратите внимание на условие выхода из внутреннего цикла **j < col** здесь вместо **i** используется **col**.

<h2 id="pattern-11"><span class="attention">Паттерн</span> одиннадцать (бинарный треугольник вправо)</h2>

<pre>
1
0 1
1 0 1
0 1 0 1
1 0 1 0 1
</pre>

Данный паттерн выводится точно так же как и паттерн 2. За исключением того, что вместо звездочек нужно чередовать 0 и 1.

Так как первая строка начинается с 1, то зададим стартовую позицию равною 1, создав переменную **start** и присвоив ей значение 1, **start = 1**.

Далее можно проследить, что каждая четная строка начинается с 0 поэтому ниже переменной **start** добавим условие если итерация внешнего цикла четная, то переменная **start = 0**.

Теперь внутренний цикл будет выводить значение переменной **start**. Чтобы менять значение переменной **start** во внутреннем цикле, присвоим переменной start значение равное **1 - start**.

Внешний цикл будет определять стартовою позицию для переменной **start**, например 1. Внутренний цикл выведет эту 1 и изменит значение переменной start = 1 - 1, теперь переменная start равна 0. Далее выводится 0, затем присваивается опять новое значение start = 1 - 0, теперь переменная start равна 1 и так далее.

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  // внешний цикл выводит строки
  // так как нужно 5 строк, то выводятся строки от 0 до 5.
  for (let i = 0; i < n; i++) {

    // определяем стартовую позицию
    let start = 0
    if (i % 2 === 0) start = 1

    // внутренний цикл выводит столбцы
    // не более чем порядковый номер внешней итерации
    for (let j = 0; j <= i; j++) {
      // при первой итерации выводим значение присвоенное внешним циклом
      result += `${start}`

      // при последующих итерациях выводится новое значение
      start = 1 - start
    }

    // итерация внешнего цикла завершилась
    // переводим каретку (курсор) на новую строку
    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-12"><span class="attention">Паттерн</span> двенадцать (две треугольные башни)</h2>

<pre>
1      1
12    21
123  321
12344321
</pre>

{% capture code %}
console.log(pattern(4))

function pattern(n) {
  let result = '\n'

  let space = 2 * (n - 1)

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      result += j
    }

    for (let j = 1; j <= space; j++) {
      result += ' '
    }

    for (let j = i; j > 0; j--) {
      result += j
    }

    result += '\n'
    space -= 2
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-13"><span class="attention">Паттерн</span> тринадцать (нарастающий числовой треугольник)</h2>

<pre>
1
2 3
4 5 6
7 8 9 10
11 12 13 14 15
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  let start = 1

  for (let i = 0; i < n; i++) {
    for (let j = 0; j <= i; j++) {
      result += `${start} `
      start += 1
    }

    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-14"><span class="attention">Паттерн</span> четырнадцать (нарастающий буквенный треугольник)</h2>

<pre>
A
AB
ABC
ABCD
ABCDE
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  let ch = 'A'.charCodeAt()

  for (let i = 0; i < n; i++) {
    for (let j = ch; j <= ch + i; j++) {
      result += String.fromCharCode(j)
    }

    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-15"><span class="attention">Паттерн</span> пятнадцать (обратный нарастающий буквенный треугольник)</h2>

<pre>
ABCDE
ABCD
ABC
AB
A
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  let ch = 'A'.charCodeAt()

  for (let i = n; i > 0; i--) {
    for (let j = ch; j < ch + i; j++) {
      result += String.fromCharCode(j)
    }

    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-16"><span class="attention">Паттерн</span> шестнадцать (буквенный треугольник вариант 2)</h2>

<pre>
A
BB
CCC
DDDD
EEEEE
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  let ch = 'A'.charCodeAt()

  for (let i = 0; i < n; i++) {
    for (let j = 0; j <= i; j++) {
      result += String.fromCharCode(ch)
    }

    result += '\n'
    ch += 1
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-17"><span class="attention">Паттерн</span> семнадцать (буквенный равносторонний треугольник)</h2>

<pre>
    A
   ABA
  ABCBA
 ABCDCBA
ABCDEDCBA
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  for (let i = 0; i < n; i++) {
    for(let j = 0; j < n - i - 1; j++){
      result += ' '
    }

    let ch = 'A'.charCodeAt()
    let breakpoint = (2 * i + 1) / 2

    for (let j = 1; j <= 2 * i + 1; j++) {
      result += String.fromCharCode(ch)

      if (j <= breakpoint) ch++
      else ch--
    }

    for (let j = 0; j < n - i - 1; j++) {
      result += ' '
    }

    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-18"><span class="attention">Паттерн</span> восемнадцать (развернутый буквенный треугольник)</h2>

<pre>
E
D E
C D E
B C D E
A B C D E
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  let ch = 'E'.charCodeAt()

  for (let i = 0; i < n; i++) {
    for (let j = ch - i; j <= ch; j++) {
      result += String.fromCharCode(j) + ' '
    }

    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-19"><span class="attention">Паттерн</span> девятнадцать (внутренний ромб)</h2>

<pre>
**********
****  ****
***    ***
**      **
*        *
*        *
**      **
***    ***
****  ****
**********
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  let space = 0

  for (let i = 0; i < n; i++) {
    for (let j = 1; j <= n - i; j++) {
      result += '*'
    }

    for (let j = 0; j < space; j++) {
      result += ' '
    }

    for (let j = 1; j <= n - i; j++) {
      result += '*'
    }

    result += '\n'
    space += 2
  }

  space = 2 * n - 2

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      result += '*'
    }

    for (let j = 0; j < space; j++) {
      result += ' '
    }

    for (let j = 1; j <= i; j++) {
      result += '*'
    }

    result += '\n'
    space -= 2
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-20"><span class="attention">Паттерн</span> двадцать (бабочка)</h2>

<pre>
*        *
**      **
***    ***
****  ****
**********
****  ****
***    ***
**      **
*        *
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  let space = 2 * n - 2

  for (let i = 1; i <= 2 * n - 1; i++) {
    let stars = i

    if (i > n) stars = 2 * n - i

    for (let j = 1; j <= stars; j++) {
      result += '*'
    }

    for (let j = 1; j <= space; j++) {
      result += ' '
    }

    for (let j = 1; j <= stars; j++) {
      result += '*'
    }

    if (i < n) space -= 2
    else space += 2

    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-21"><span class="attention">Паттерн</span> двадцать один (прозрачный квадрат)</h2>

<pre>
******
*    *
*    *
*    *
*    *
******
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      if(i === 0 || j === 0 || i === n - 1 || j === n - 1) {
        result += "*"
      } else {
        result += " "
      }
    }

    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="pattern-22"><span class="attention">Паттерн</span> двадцать два (уменьшающаяся матрица)</h2>

<pre>
5 5 5 5 5 5 5 5 5
5 4 4 4 4 4 4 4 5
5 4 3 3 3 3 3 4 5
5 4 3 2 2 2 3 4 5
5 4 3 2 1 2 3 4 5
5 4 3 2 2 2 3 4 5
5 4 3 3 3 3 3 4 5
5 4 4 4 4 4 4 4 5
5 5 5 5 5 5 5 5 5
</pre>

{% capture code %}
console.log(pattern(5))

function pattern(n) {
  let result = '\n'

  for(let i = 0; i < 2 * n - 1; i++) {
    for(let j = 0; j < 2 * n - 1; j++) {

      let top = i
      let left = j
      let bottom = (2 * n - 2) - i
      let right = (2 * n - 2) - j

      result += (n - Math.min(Math.min(top, bottom), Math.min(left, right))) + ' '
    }

    result += '\n'
  }

  return result
}
{% endcapture %}
{% include component/code.html lang='bash' content=code %}
