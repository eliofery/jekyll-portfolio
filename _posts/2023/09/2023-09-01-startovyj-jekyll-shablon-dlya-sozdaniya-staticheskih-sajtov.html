---
layout: post
title: Стартовый Jekyll шаблон для создания статических сайтов
date: 2023-09-01 09:16 +0600
description: Создадим стартовый <b>Jekyll</b> шаблон на основе которого в дальнейшем можно будет разрабатывать статические сайты. В работе будут использованы такие технологии как <b>html</b>, <b>scss</b>, <b>webp</b>, <b>npm</b>.
image: cover.jpg
alt: Стартовый Jekyll шаблон
category: frontend
tags: [jekyll, html, scss, webp, npm]
source: https://github.com/eliofery/jekyll-template
published: true
sitemap: true
excerpt_separator: "<!--more-->"
---

<p>Создадим стартовый <b>Jekyll</b> шаблон на основе которого в дальнейшем можно будет разрабатывать статические сайты. В работе будут использованы такие технологии как <b>html</b>, <b>scss</b>, <b>webp</b>, <b>npm</b>.</p>

<!--more-->

<h2><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Почему Jekyll</a></li>
  <li><a href="#base">Базовая установка</a></li>
  <li><a href="#init">Создание проекта</a></li>
  <li><a href="#base-setting">Базовая настройка</a></li>
  <li><a href="#architecture">Архитектура шаблонов</a></li>
  <li><a href="#posts">Страницы, статьи и коллекции</a></li>
  <li><a href="#auto-posts">Автоматизация создания различных типов записей</a></li>
  <li><a href="#layout">Шаблоны для типов записей</a></li>
  <li><a href="#includes">Включаемые области и пользовательские данные</a></li>
  <li><a href="#assets">Ресурсы проекта</a></li>
  <li><a href="#seo">Seo оптимизация</a></li>
  <li><a href="#pagination">Постраничная пагинация</a></li>
  <li><a href="#picture">Изображения на сайте</a></li>
  <li><a href="#end">Подведем итоги</a></li>
</ol>

<h2 id="intro"><span class="attention">Почему</span> Jekyll</h2>

<p><b>Jekyll</b> - это генератор статических страниц, который позволяет создавать веб-сайты, состоящие из статических HTML-файлов, без необходимости использования серверных технологий или баз данных. Благодаря чему вместо покупки даже самомального виртуального хостинга можно использовать бесплатный <b>GitHub Pages</b>.</p>

<p>По функциональности он практически не уступает тем же самым <b>CMS</b> системам для введения блога, но на много производительней и прост в освоении. Идеальный вариант для создания новостных порталов, блогов и портфолио. В частности данный сайт написан на <b>Jekyll</b>.</p>

<p>С официальным источником <b>Jekyll</b> можно <a href="https://jekyllrb.com/" target="_blank" rel="nofollow">ознакомиться здесь</a>.</p>

<h2 id="base"><span class="attention">Базовая</span> установка Jekyll</h2>

<p>Полная инструкция по установке <b>Jekyll</b> описана на <a href="https://jekyllrb.com/docs/installation/ubuntu/" target="_blank" rel="nofollow">официальном сайте</a>, здесь же я приведу пример установки на дистрибутивы семейства <b>Debian</b>.</p>

<p>Установите <b>Ruby</b> и других необходимых зависимостей.</p>

{% include component/code.html lang='bash' content='sudo apt install ruby-full build-essential zlib1g-dev' %}

<p>Настройки для учетной записи пользователя. Введите в терминале представленные команды попорядку.</p>

{% capture code %}
echo '# Install Ruby Gems to ~/gems' >> ~/.bashrc
echo 'export GEM_HOME="$HOME/gems"' >> ~/.bashrc
echo 'export PATH="$HOME/gems/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Установка <b>Jekyll</b> и <b>Bundler</b>.</p>

{% include component/code.html lang='bash' content='gem install jekyll bundler' %}

<h2 id="init"><span class="attention">Создание</span> проекта Jekyll</h2>

<p>Полную инструкцию по создании проекта <b>Jekyll</b> описана на <a href="https://jekyllrb.com/docs/" target="_blank" rel="nofollow">официальном сайте</a>.</p>

<p>Создадим <b>Jekyll</b> проект в каталоге <b>mysite</b>. Для этого в терминале введем следующую команду.</p>

{% include component/code.html lang='bash' content='jekyll new mysite' %}

<p>Переходим в каталог mysite.</p>

{% include component/code.html lang='bash' content='cd mysite' %}

<p>Устанавливаем расширения прописанные в файле <b>Gemfile</b>.</p>

{% include component/code.html lang='bash' content='bundle install' %}

<p>Запускаем проект в режиме разработки.</p>

{% include component/code.html lang='bash' content='bundle exec jekyll serve' %}

<p>Переходим в браузере по ссылке <b>http://localhost:4000</b>. Так выглядит стандартный шаблон <b>Jekyll</b>, который в рамках этой статьи мы переделаем и улучшим.</p>

<figure>
  {% include component/picture.html fancybox='true' slug=page.slug img='img-1.jpg' type='original' alt='Стандартный шаблон Jekyll' %}
  <figcaption>Так выглядит стандартный шаблон <b>Jekyll</b>.</figcaption>
</figure>

<h2 id="base-setting"><span class="attention">Базовая</span> настройка Jekyll</h2>

<p>Подкорректируем конфигурационные файлы <b>Jekyll</b> для дальнейшей работы.</p>

<h3>Gemfile конфиг</h3>

<p><b>Gemfile</b> используется для управления зависимостями и плагинами в вашем проекте. Здесь мы будем указывать дополнительный функционал для нашего шаблона например пагинацию, конвертацию изображений в <b>webp</b> формат и т.п.</p>

<p>Откроем файл <b>Gemfile</b> и отредактируем его следующим образом.</p>

{% capture code %}
# Указывает источник, из которого следует загружать расширения для проекта.
source "https://rubygems.org"

# Версия jekyll
gem "jekyll", "~> 4.3.2"

# Используемые в проекте расширения
group :jekyll_plugins do
  # RSS
  # https://github.com/jekyll/jekyll-feed
  gem "jekyll-feed", "~> 0.12"
end

# Добавление расширений, которые предоставляют информацию и возможность работы с часовыми поясами (timezone).
# Они полезны, когда вам нужно работать с датами и временем в разных часовых поясах.
platforms :mingw, :x64_mingw, :mswin, :jruby do
  gem "tzinfo", ">= 1", "< 3"
  gem "tzinfo-data"
end

# Ускоритель производительности для просмотра каталогов в Windows
gem "wdm", "~> 0.1.1", :platforms => [:mingw, :x64_mingw, :mswin]

# Заблокирует расширение `http_parser.rb` на версии `0.6.x` в сборках JRuby,
# поскольку более новые версии расширения не имеют аналога Java
gem "http_parser.rb", "~> 0.6.0", :platforms => [:jruby]
{% endcapture %}
{% include component/code.html lang='Gemfile' content=code %}

<p>Здесь мы удалили <b>gem "minima", "~> 2.5"</b>, который отвечает за установку и использования шаблона <b>minima</b> по умолчанию. В рамках статьи мы будем создавать свой собственный шаблон.</p>

<h3>_config.yml конфиг</h3>

<p>Содержит системные, пользовательские глобальные переменные, а так же настройки для установленных расширений. Доступ к глобальным переменным будет осуществляться так: <b>&#123;&#123; site.myvariable &#125;&#125;</b>.</p>

<p>Откроем файл <b>_config.yml</b> и отредактируем его следующим образом.</p>

{% capture code %}
title: Основной заголовок сайта
email: your-email@example.com
description: Основное описание сайта
baseurl: "" # подпуть вашего сайта, например. /blog
url: "" # базовое имя хоста и протокол вашего сайта, например. http://example.com

# Подключение плагинов
plugins:
  - jekyll-feed

# Исключение файлов и каталогов из сборки
# Файлы и каталоги которые не попадут в каталог _site
# exclude:
#   - .sass-cache/
#   - .jekyll-cache/
#   - gemfiles/
#   - Gemfile
#   - Gemfile.lock
#   - node_modules/
#   - vendor/bundle/
#   - vendor/cache/
#   - vendor/gems/
#   - vendor/ruby/
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<p>Здесь мы удалили <b>twitter_username</b> и <b>github_username</b>, это пользовательские переменные, используемые в шаблоне <b>minima</b>. Если в рамках нашего шаблона нужно будет создать ссылки на социальные сети, то мы их добавим позже.</p>

<p>Так же удалили подключение шаблона <b>theme: minima</b>.</p>

<h3>Установим зависимости</h3>

<p>Для того чтобы установить все расширения и зависимости, указанные в файле <b>Gemfile</b> выполним в терминале команду.</p>

{% include component/code.html lang='bash' content='bundle install' %}

<p>На экране должно отобразиться примерно следующее уведомление.</p>

<pre><code>Bundle complete! 6 Gemfile dependencies, 32 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.
</code></pre>

<p>Запустим проект в режиме разработки.</p>

{% include component/code.html lang='bash' content='bundle exec jekyll serve' %}

<p>Перейдем по ссылке <b>http://127.0.0.1:4000</b>, где нас встретит пустая страница. На этом базовую настройку и подготовку к дальнейшей работе над шаблоном мы завершили.</p>

<h2 id="architecture"><span class="attention">Архитектура</span> шаблонов Jekyll</h2>

<p>В этом разделе мы познакомимся с тем как устроенна архитектура шаблонов <b>Jekyll</b>, заложим фундамент для дальнейшего создания разделов сайта.</p>

<p>Структура проекта по умолчанию после установки выглядит так.</p>

{% capture code %}
./
├── _posts
│    └── 2023-09-03-welcome-to-jekyll.markdown
├── .editorconfig
├── .gitattributes
├── .gitignore
├── 404.html
├── _config.yml
├── about.markdown
├── Gemfile
├── Gemfile.lock
├── index.markdown
└── README.md
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Я специально не включил некоторые каталоги такие как <b>_site</b>, <b>.jekyll-cache</b> и т.п. Так как они создаются непосредственно при сборке проекта и не участвуют в его создании.</p>

<p><b>Jekyll</b> умеет работать как с файлами формата <b>.markdown</b> или <b>.md</b>, так и с форматом <b>.html</b>. По умолчанию в корне проекта располагаются файлы <b>404.html</b>, <b>about.markdown</b> и <b>index.markdown</b>. Которые отвечают за отображение страниц <b>"404"</b>, <b>"О нас"</b> и <b>"Главная страница"</b> соответственно. Это статические страницы используемые на сайте.</p>

<p>Как видно из примера статические страницы можно создавать в корне шаблона, но в дальнейшем когда проект будет разрастаться, искать нужные страницы вперемешку с конфигурационными файлами будет не удобно. Поэтому я предлагаю создать отдельный каталог в корне шаблона и назвать его <b>_pages</b>. Нижний прочерк <b>_</b> в названии файлов и каталогов, указывает <b>Jekyll</b> не перемещать их в каталог <b>_site</b>, который хранит собранный проект.</p>

<p>Создадим в корне проекта каталог <b>_pages</b> и переместим в него файлы <b>404.html</b>, <b>about.markdown</b> и <b>index.markdown</b>. Должно получиться следующее.</p>

{% capture code %}
./_pages/
├── 404.html
├── about.markdown
└── index.markdown
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Далее укажем <b>Jekyll</b>, чтобы он при сборке проекта просматривал файлы внутри каталога <b>_pages</b>. Для этого откроем файл <b>_config.yml</b> и перед конструкцией <b>exclude</b> добавим.</p>

{% capture code %}
# Включение файлов и каталогов в сборку
include:
  - _pages
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<p>Перезапустим проект в режиме разработки. Теперь если обновить главную страницу в браузере, то мы увидим вместо пустой страницы, файлы содержащиеся в каталоге <b>_site</b>. Так произошло потому что <b>Jekyll</b> при сборке проекта не нашел <b>index</b> файлы в корне проекта, так как мы его перенесли. Чтобы исправить этот момент, откроем файлы <b>404.html</b>, <b>about.markdown</b> и <b>index.markdown</b> и добавим настройку <b>permalink</b>.</p>

{% capture code %}
---
layout: home
permalink: /
---
{% endcapture %}
{% include component/code.html lang='index.markdown' content=code %}

{% capture code %}
---
layout: page
title: About
permalink: /about
---
{% endcapture %}
{% include component/code.html lang='about.markdown' content=code %}

{% capture code %}
---
layout: default
permalink: /404
---
{% endcapture %}
{% include component/code.html lang='404.html' content=code %}

<p>Теперь страницы по указанным нами ссылкам должны успешно отображаться.</p>

<h2 id="posts"><span class="attention">Страницы</span>, статьи и коллекции</h2>

<p>В <b>Jekyll</b> для отображения контента имеются несколько типов записей.</p>

<ul>
  <li><b>_pages</b> - страницы отображают контент, который не имеет категорий.</li>
  <li><b>_posts</b> - страницы отображают контент с статьями, который имеет категории.</li>
  <li><b>collections</b> - страницы отображают контент с пользовательским типом записи.</li>
</ul>

<p>Любой тип записи имеет некоторую конструкцию настройки, которая позволяет парсеру <b>Jekyll</b> правильно собрать страницу. Так как <b>Jekyll</b> выступает так же в роле шаблонизатора, то нам не нужно дублировать одну и туже разметку на всех страницах это позволяет сконцентрироваться только на контенте при заполнении содержимого страницы.</p>

<h3>Расширение jekyll-sitemap</h3>

<p>Расширение автоматически создает на основе имеющегося контента <b>sitemap.xml</b> файл, который в последствии поможет в <b>seo</b> продвижении.</p>

<p>Перед созданием типов записей установим расширение <b>jekyll-sitemap</b> с которым более детально можно ознакомиться на
  <a href="https://github.com/jekyll/jekyll-sitemap" target="_blank" rel="nofollow">официальном сайте</a>. Откроем файл <b>Gemfile</b> и добавим в группу плагинов расширение.</p>

{% capture code %}
# Добавляет sitemap
# https://github.com/jekyll/jekyll-sitemap
gem "jekyll-sitemap"
{% endcapture %}
{% include component/code.html lang='Gemfile' content=code %}

<p>Установим новое расширение <b>jekyll-sitemap</b>.</p>

{% include component/code.html lang='bash' content='bundle install' %}

<p>Добавим расширение <b>jekyll-sitemap</b> в список плагинов в файле <b>_config.yml</b>.</p>

{% capture code %}
# Подключение плагинов
plugins:
  - jekyll-feed
  - jekyll-sitemap
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<h3>Тип записи "Страницы"</h3>

<p>Детальное описание по работе со страницами описана в <a href="https://jekyllrb.com/docs/pages/" target="_blank" rel="nofollow">официальной документации</a> <b>Jekyll</b>.</p>

<p>Мы уже знаем, что страницы находятся в каталоге <b>_pages</b> и если возникнет необходимость в создании новой страницы, то нам достаточно создать новый файл в каталоге <b>_pages</b> в формате <b>.md</b> или <b>.html</b>. Формат <b>markdown</b> и <b>md</b> это синонимы одного и того же типа файла, поэтому если есть надобность в использовании формата <b>.md</b>, то лучше сразу давать такой тип файлу вместо более длинного <b>markdown</b>.</p>

<p>Для страниц я предпочитаю работать с форматом <b>html</b>, но в принципе так же можно оставить формат <b>md</b>, так как в <b>Jekyll</b> умеет парсить <b>html</b> теги внутри <b>md</b> файла. Каждому файлу в каталоге <b>_pages</b> я изменю расширение с <b>markdown</b> на <b>html</b>, вы же если хотите, можете укоротить расширение до <b>md</b>.</p>

{% capture code %}
./_pages/
├── 404.html
├── about.html
└── index.html
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Откроем файл <b>index.html</b> и отредактируем его.</p>

{% capture code %}
---
layout: home
title: Главная страница шаблона
description: Описание главной страницы шаблона
permalink: /
sitemap: true
---

&lt;h1&gt;Главная страница&lt;/h1&gt;

&lt;p&gt;Пример главной страницы&lt;/p&gt;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>То что находится между разделителями <b>--- ---</b> является конфигурацией для шаблонизатора, используя указанные в них параметры он будет собирать страницу. Ниже разделителя располагается сам контент страницы.</p>

<p>Рассмотрим каждый параметр отдельно.</p>

<ul>
  <li><b>layout</b> - название шаблона, который будет использоваться как основа страницы. Более подробно про шаблон будет ниже.</li>
  <li><b>title</b> - заголовок страницы, который переопределяет стандартный заголовок прописанный в <b>_config.yml</b></li>
  <li><b>description</b> - описание страницы, которое переопределяет стандартное описание прописанное в <b>_config.yml</b></li>
  <li><b>permalink</b> - ссылка на страницу, так как страницы были перенесены в отдельный каталог <b>_pages</b>, то нужно всегда указывать этот параметр</li>
  <li><b>sitemap</b> - является параметром расширения <b>jekyll-sitemap</b> и отвечает за карту сайта. По умолчанию всегда включен для всех страниц, если необходимо исключить какую либо страницу из <b>sitemap.xml</b>, то нужно указать явно этот параметр <b>sitemap: false</b> для каждой такой страницы.</li>
</ul>

<h3>Тип записи "Статьи"</h3>

<p>Детальное описание по работе со статьями описана в <a href="https://jekyllrb.com/docs/posts/" target="_blank" rel="nofollow">официальной документации</a> <b>Jekyll</b>.</p>

<p>Тип записи <b>Статьи</b> находятся в каталоге <b>_posts</b> и если возникнет необходимость в создании новой записи, то нужно создать новый файл в каталоге <b>_posts</b> в формате <b>.md</b> или <b>.html</b>.

<p>Для файлов с постами так же как и для страниц, выбираем формат <b>html</b> или <b>md</b>, я оставлю <b>md</b>.</p>

{% capture code %}
./_posts/
└── 2023-09-03-welcome-to-jekyll.md
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Как мы можем заметить название поста отличается от названия страницы, в нем присутствует приставка в виде даты создания <b>2023-09-03-</b>welcome-to-jekyll.html. Это не обязательно, но необходимо для создания архивных страницы. Поэтому рекомендую придерживаться этого правила в названии файлов этого типа записи.</p>

<p>Так же в будущем постов может стать очень много и хорошо бы их структурировать по годам и месяцам. Для этого создадим внутри каталога <b>_posts</b>, каталог с годом записи <b>2023</b>, а внутри каталога <b>2023</b> создадим каталог с числом месяца <b>09</b>. Переместим в него файл с постом, должно получиться так.</p>

{% capture code %}
./_posts/
└── 2023
  └── 09
    └── 2023-09-03-welcome-to-jekyll.html
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Откроем файл <b>2023-09-03-welcome-to-jekyll.html</b> и изменим его содержимое.</p>

{% capture code %}
---
layout: post
title:  "Добро пожаловать в Jekyll!"
date:   2023-09-03 12:02:32 +0600
description: Тестовая вступительная запись
category: jekyll
tags: [jekyll, html, css]
published: true
sitemap: true
excerpt_separator: "&lt;!--more--&gt;"
---

Тестовая вступительная запись

&lt;!--more--&gt;

Вы найдете этот пост в своем каталоге `_posts`. Отредактируйте его и перестройте сайт, чтобы увидеть изменения. Вы можете перестроить сайт разными способами, но наиболее распространенным способом является запуск `jekyll serve`, который запускает веб-сервер и автоматически восстанавливает ваш сайт при обновлении файла.

Jekyll требует, чтобы файлы сообщений блога имели имена в следующем формате:

`YEAR-MONTH-DAY-title.md`

Где `Год` — четырехзначное число, `Месяц` и `День` — двузначные числа, а `md` — это расширение файла, представляющее формат, используемый в файле. После этого добавьте необходимую вступительную часть. Взгляните на источник этого поста, чтобы получить представление о том, как это работает.

Jekyll также предлагает мощную поддержку фрагментов кода:

{% highlight ruby %}
def print_hi(name)
  puts "Hi, #{name}"
end
print_hi('Tom')
#=> prints 'Hi, Tom' to STDOUT.
{% endhighlight %}

Проверьте [Jekyll docs][jekyll-docs] для получения дополнительной информации о том, как максимально эффективно использовать Jekyll. Сообщите обо всех ошибках/запросах на новые функции по адресу [Jekyll’s GitHub repo][jekyll-gh]. Если у вас есть вопросы, вы можете задать их на [Jekyll Talk][jekyll-talk].

[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/

{% endcapture %}
{% include component/code.html lang='md' content=code %}

<p>Для наполнения контента содержимым используется <b>Markdown</b> разметка. С большинством параметров мы уже знакомы, рассмотрим новые для нас.</p>

<ul>
  <li><b>date</b> - дата добавления статьи</li>
  <li><b>category</b> - название категории к которой относится статья, может быть во множественном числе, например categories: [раз, два], можно создать результирующую страницу с записями определенной категории</li>
  <li><b>tags</b> - что-то на подобии категорий только без результирующей страницы</li>
  <li><b>published</b> - статус публикации статьи, если <b>false</b> страница не будет отображаться</li>
  <li><b>permalink</b> - для статей можно не указывать, он будет автоматически сгенерирован согласно шаблону который мы в дальнейшем настроем</li>
  <li><b>excerpt_separator</b> - разделитель между коротким описанием и полным описание статьи</li>
</ul>

<p>Для того чтобы переопределить стандартный вид ссылки на статью, нужно будет добавить параметр <b>permalink</b> в файл <b>_config.yml</b>. Более подробно о ссылках читайте в
  <a href="https://jekyllrb.com/docs/permalinks/#built-in-formats" target="_blank" rel="nofollow">официальной документации</a>.</p>

{% capture code %}
permalink: /blog/:name-:categories.html
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<p>В данном примере ссылка на любую статью будет начинаться со слова <b>blog</b> затем имя файла со статьей - название категории и заканчиваться ссылка будет форматом <b>.html</b>. В принципе можно не добавлять формат <b>.html</b>, но браузер <b>Firefox</b> может тогда не открыть страницу.</p>

<h3>Тип записи "Коллекции"</h3>

<p>Детальное описание по работе с коллекциями описана в <a href="https://jekyllrb.com/docs/collections/" target="_blank" rel="nofollow">официальной документации</a> <b>Jekyll</b>.</p>

<p>Тип записи <b>Коллекции</b> это особый вид пользовательской записи у него нет заранее определенного каталога, он нужен для того чтобы как то по-особенному сгруппировать связанный контент, например рецепты, портфолио, выступления и т.п.</p>

<p>Для того чтобы создать коллекцию, откроем файл <b>_config.yml</b> и добавим.</p>

{% capture code %}
# Коллекции
collections:
  recipe:
    output: true
    permalink: /:collection/:name-:i_day:i_month:short_year
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<ul>
  <li><b>collections</b> - перечисление пользовательских коллекций
  <ul>
    <li><b>recipe</b> - любое пользовательское имя коллекции, в данном примере мы будем создавать рецепты, ниже представлены параметр коллекции recipe, у каждой коллекции будут свои настройки
    <ul>
      <li><b>output</b> - определяет нужно ли создавать для каждой коллекции отдельную страницу</li>
      <li><b>permalink</b> - шаблон ссылки на страницу коллекции, здесь у нас идет в начале ссылки имя коллекции, затем название страницы коллекции и потом день, месяц, год добавления записи.</li>
    </ul>
    </li>
  </ul>
  </li>
</ul>

<p>После того как мы добавили в конфигурационный файл коллекцию давайте теперь ее создадим. Для этого в корне шаблона создаем каталог с именем нашей коллекции <b>_recipe</b>. Внутри данного каталога создаем файл например <b>borscht-soup.md</b> со следующим содержимым.</p>

{% capture code %}
---
layout: post
title: Как приготовить борщ по классическому рецепту
date: 2023-08-31 13:39 +0600
description: Налейте в кастрюлю холодную воду, выложите мясо и поставьте на средний огонь. Бульон будет вкуснее, если использовать именно мясо на кости.
published: true
sitemap: false
excerpt_separator: "&lt;!--more--&gt;"
---

Налейте в кастрюлю холодную воду, выложите мясо и поставьте на средний огонь. Бульон будет вкуснее, если использовать именно мясо на кости.

&lt;!--more--&gt;

## Начало готовки

Налейте в кастрюлю холодную воду, выложите мясо и поставьте на средний огонь. Бульон будет вкуснее, если использовать именно мясо на кости.
{% endcapture %}
{% include component/code.html lang='md' content=code %}

<p>Перезапустим проект в режиме разработки и откроем страницу <b>http://127.0.0.1:4000/recipe</b>. Мы увидим ссылку на страницу с рецептом причем ее имя сгенерировалось согласно, указанному в файле <b>_config.yml</b> шаблону. Если перейти по этой ссылке мы должны увидеть содержимое контента файла <b>borscht-soup.md</b>.</p>

<h2 id="auto-posts"><span class="attention">Автоматизация</span> создания различных типов записей</h2>

<p>Можно было заметить, что создавать вручную файлы с записями не совсем удобно. Было бы здорово как-нибудь автоматизировать этот процесс. Есть одно решение, связанное с установкой определенного расширения и настройкой шаблонов для каждого типа записи.</p>

<p>Добавим в файл <b>Gemfile</b> в группу плагинов новое расширение <a href="https://github.com/jekyll/jekyll-compose" target="_blank" rel="nofollow"><b>jekyll-compose</b></a>.</p>

{% capture code %}
# Добавляет команды для создания записи, страницы или черновика.
# https://github.com/jekyll/jekyll-compose
gem "jekyll-compose"
{% endcapture %}
{% include component/code.html lang='Gemfile' content=code %}

<p>Установим новое расширение <b>jekyll-compose</b>.</p>

{% include component/code.html lang='bash' content='bundle install' %}

<p>Откроем файл <b>_config.yml</b> и ниже определений коллекций добавим следующие конфигурации.</p>

{% capture code %}
# Набор правил по умолчанию для создаваемых страниц через терминал
jekyll_compose:
  auto_open: true
  default_front_matter:
    drafts:
      description:
      category:
      tags: []
      published: false
      sitemap: false
      excerpt_separator: <!--more-->
    posts:
      description:
      category:
      tags: []
      published: true
      sitemap: true
      excerpt_separator: <!--more-->
    recipe:
      layout: post
      description:
      excerpt_separator: <!--more-->
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<p>Рассмотрим параметры по подробней.</p>

<ul>
  <li><b>jekyll_compose</b> - настройки расширения jekyll_compose
    <ul>
      <li><b>auto_open</b> - при создании файла будет автоматически открывать его в редакторе</li>
      <li><b>default_front_matter</b> - форматы записей
        <ul>
          <li><b>drafts</b> - черновики, записи которые не будут отображаться на сайте</li>
          <li><b>posts</b> - статьи</li>
          <li><b>recipe</b> - рецепты</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>В настройках этой конфигурации мы можем предопределить заранее какие-то параметры, а так же добавить не стандартные пользовательские, чтобы затем использовать их на странице.</p>

<p>Обозначим редактор кода по умолчанию в котором будет открываться созданный файл записи, для <b>IDE PhpStorm</b> это будет <b>phpstorm</b>, для <b>VSCode</b> это будет <b>code</b>.</p>

{% capture code %}
export JEKYLL_EDITOR=phpstorm

# Или

export JEKYLL_EDITOR=code
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Список команд для манипулирования материалом на сайте.</p>

{% capture code %}
# Создаст новую страницу
# Страницы будут создаваться в корне проекта, перенести их в каталог _page придется вручную
bundle exec jekyll page "My New Page"

# Создаст новую статью
# Статья создастся в каталоге _posts перенести ее в 2023/09 придется вручную
bundle exec jekyll post "My New Post"

# Создаст новую коллекцию
bundle exec jekyll compose "My New Post" --collection "name-collection"

# Создаст новый черновик
# Черновики создаются в каталоге _drafts
bundle exec jekyll draft "My new draft"

# Опубликует указанный черновик
bundle exec jekyll publish _drafts/my-new-draft.md

# Отправит активную статью в черновик
bundle exec jekyll unpublish _posts/2014-01-24-my-new-draft.md
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Попробуйте создать любой тип записи выполнив команду в терминале. Должен создастся файл с указанным типом записи, автоматически открыться в заданном редакторе и иметь предопределенное в файле <b>_config.yml</b> содержимое параметров, которые останется лишь немного дополнить и подкорректировать.</p>

<p>На сколько это можно было сделать мы упростили себе рутину по созданию файлов с записями.</p>

<h2 id="layout"><span class="attention">Шаблоны</span> для типов записей</h2>

<p>Ранее мы познакомились с таким параметров как <b>layout</b> в записях. Он содержал название шаблона, который используется как основа для страницы. В этом разделе мы подробнее разберем эту тему, создадим свой шаблон и применим его к записям.</p>

<p>В корне проекта создадим каталог <b>_layouts</b>. Внутри каталога <b>_layouts</b> создадим файл <b>default.html</b>. Он будет содержать базовый шаблон для сайта, от которого другие шаблоны будут в дальнейшем наследоваться.</p>

<p>Прежде чем приступить к заполнению шаблона <b>default.html</b> содержимым, расширим базовый функционал <b>Jekyll</b> шаблонизатора, установив расширение
  <a href="https://github.com/rustygeldmacher/jekyll-contentblocks" target="_blank" rel="nofollow"><b>jekyll-contentblocks</b></a>. Для этого откроем файл <b>Gemfile</b> и в группу плагинов добавим новое расширение.</p>

{% capture code %}
# Предоставляет механизм для передачи содержимого со страниц в их родительские макеты.
# https://github.com/rustygeldmacher/jekyll-contentblocks
gem 'jekyll-contentblocks'
{% endcapture %}
{% include component/code.html lang='Gemfile' content=code %}

<p>Данное расширение предоставит механизм для передачи содержимого со страниц в их родительские макеты.<br> Установим его.</p>

{% include component/code.html lang='bash' content='bundle install' %}

<p>Теперь можно приступить к созданию основного шаблона для страницы сайта. Отредактируем файл <b>default.html</b> следующим образом.</p>

{% capture code %}
&lt;!DOCTYPE html&gt;
&lt;html class="no-js" lang="&#123;&#123; page.lang | default: site.lang | default: 'ru' &#125;&#125;"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;

  &lt;title&gt;&#123;&#123; page.title &#125;&#125;&lt;/title&gt;

  &lt;base href="&#123;&#123; site.baseurl &#125;&#125;"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="layout"&gt;
  &#123;% contentblock header %&#125;

  &lt;main class="layout__main"&gt;
    &#123;% contentblock content %&#125;
  &lt;/main&gt;

  &#123;% contentblock footer %&#125;
&lt;/div&gt;

&#123;% contentblock script %&#125;
&lt;/body&gt;
&lt;/html&gt;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Конструкция <b>&#123;&#123; &#125;&#125;</b> выводит содержимое переменной на странице. В данном примере <b>&#123;&#123; page.lang | default: site.lang | default: 'ru' &#125;&#125;</b> будет выводиться содержимое переменной <b>lang</b>, которая берется внутри разделителя <b>--- ---</b> для текущей записи, отображаемой на странице. Если переменная <b>lang</b> не будет найдена, тогда будет браться содержимое глобальной переменной <b>lang</b> из файла <b>_config.yml</b>. Если такой переменной и там не будет, то по умолчанию подставится значение <b>ru</b>.</p>

<p>Конструкции <b>{% contentblock header | content | footer | script %}</b> создаются благодаря установленному расширению <b>jekyll-contentblocks</b>. Здесь мы резервируем место под определенный контент, который будет находиться внутри страниц, наследующихся от шаблона <b>default.html</b>. Каждому зарезервированному блоку задается уникальное имя.</p>

<p>В каталоге <b>_layouts</b> создадим еще один шаблон который будет наследоваться от <b>default.html</b> и назовем его <b>base.html</b>. Содержимое шаблона <b>base.html</b> будет следующим.</p>

{% capture code %}
---
layout: default
---

&#123;% contentfor header %&#125;
&lt;header&gt;
  Шапка сайта
&lt;/header&gt;
&#123;% endcontentfor %&#125;

&#123;% contentfor content %&#125;
  &#123;&#123; content &#125;&#125;
&#123;% endcontentfor %&#125;

&#123;% contentfor footer %&#125;
&lt;footer&gt;
  FOOTER
&lt;/footer&gt;
&#123;% endcontentfor %&#125;

&#123;% contentfor script %&#125;
&lt;script&gt;
  console.log('Test')
&lt;/script&gt;
&#123;% endcontentfor %&#125;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Первое, что бросается в глаза это наличие разделителя <b>--- ---</b> внутри шаблона <b>base.html</b> и его отсутствие в шаблоне <b>default.html</b>. Так как шаблон <b>default.html</b> ни от кого не наследуется, а является главным родительским шаблоном, наличие блока с разделителем в нем не обязателен, хотя ни кто не мешает его добавить при необходимости использовать какие-либо пользовательские переменные.</p>

<p>В шаблоне <b>base.html</b> напротив необходимо добавить блок с разделителем и переменной <b>layout</b>, которая должна содержать имя файла, от которого нужно наследоваться. В данном случае у нас это <b>layout: default</b> так как наследование происходит от файла <b>default.html</b>.</p>

<p>Теперь давайте подключим созданные шаблоны к главной странице сайта, файл которой находится в каталоге <b>_pages/index.html</b>. Для этого откроем файл <b>index.html</b> и отредактируем его изменив параметр <b>layout</b> на значение <b>base</b>.</p>

{% capture code %}
---
layout: base
title: Главная страница шаблона
description: Описание главной страницы шаблона
permalink: /
sitemap: true
---

&lt;h1&gt;Главная страница&lt;/h1&gt;

&lt;p&gt;Пример главной страницы&lt;/p&gt;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>При сборке главной страницы шаблонизатором <b>Jekyll</b> содержимое контентной области файла <b>index.html</b> попадет внутрь конструкции <b>&#123;% contentfor content %&#125;</b> в файле <b>base.html</b>, в свою очередь содержимое блоков <b>&#123;% contentfor %&#125;</b> внутри файла <b>base.html</b> попадет в файл <b>default.html</b> в зарезервированные блоки <b>&#123;% contentblock %&#125;</b> и так со всеми блоками, на выходе получится единая цельная страница.</p>

<p>Следует для каждого файла внутри каталогов <b>_pages</b>, <b>_posts</b> и <b>_recipe</b> изменить параметр <b>layout</b> на <b>base</b>.</p>

<h2 id="includes"><span class="attention">Включаемые</span> области и пользовательские данные</h2>

<p><b>Jekyll</b> как и многие другие шаблонизаторы позволяет выносить крупные или повторяющиеся блоки в отдельные файлы и затем подключать их в нужных местах страницы. Что позволяет не дублировать одну и туже разметку на разных страницах сайта.</p>

<p>Пользовательские данные позволяют хранить большой массив данных в отдельном файле. Затем использовать и манипулировать ими на страницах.</p>

<p>В данном разделе, чтобы ознакомиться с этим инструментарием в <b>Jekyll</b> мы создадим многоуровневое навигационное меню. Которое как мне кажется должно в полной мере раскрыть эту тему.</p>

<p>В корне проекта создадим каталог <b>_includes</b> в нем будут находиться включаемые, повторяемые конструкции сайта. Так же в корне проекта создаем каталог <b>_data</b> в котором будут содержаться файлы с пользовательскими данными.</p>

<h3>Каталог _data</h3>

<p>Начнем с каталога <b>_data</b>, создадим в нам файл <b>main-nav.yml</b>. Название может быть абсолютно любым, главное чтобы было понятно, что содержит файл. В нашем случае файл <b>main-nav.yml</b> будет содержать вложенный список ссылок для основного навигационного меню.</p>

{% capture code %}
items:
  - title: Главная
    url: /

  - title: Рецепты
    url: /recipe

    links:
      - title: Первые блюда
        url: '#'

      - title: Вторые блюда
        url: '#'
        links:
          - title: Европейская кухня
            url: '#'
          - title: Восточная кухня
            url: '#'
          - title: Азиатская кухня
            url: '#'
          - title: Русская кухня
            url: '#'

      - title: Десерт
        url: '#'
        links:
          - title: Торты
            url: '#'
          - title: Пироги
            url: '#'
          - title: Коктейли
            url: '#'

  - title: Контакты
    url: '#'
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<h3>Каталог _includes</h3>

<p>Теперь внутри каталога <b>_includes</b> создадим файлы <b>navigation.html</b> и <b>navigation-item.html</b>. Файл <b>navigation.html</b> будет хранить основную разметку навигации. Файл <b>navigation-item.html</b> будет выводить вложенные ссылки. Такое разделение нам нужно, чтобы мы могли в рекурсивном цикле пройтись по всем ссылкам в файле <b>main-nav.yml</b>, вместо того, чтобы вручную прописывать каждые вложенные ссылки.</p>

<p>Чтобы подключить включаемую область в другой файл нужно использовать конструкцию <b>&#123;% include foo-bar.html %&#125;</b>, где <b>foo-bar.html</b> полное имя с расширением подключаемого файла. Все включаемые файлы берутся из каталога <b>_includes</b>. Если внутри каталога <b>_includes</b> будут другие каталоги, а в них уже файлы это необходимо будет отобразить, например <b>&#123;% include folder/foo-bar.html %&#125;</b>.</p>

<p>Содержимое файла <b>navigation.html</b> будет следующим.</p>

{% capture code %}
&#123;% if site.data.main-nav.items %&#125;
&lt;nav class="navigation"&gt;
  &lt;ul class="navigation__list"&gt;
    &#123;% include navigation-item.html items=site.data.main-nav.items %&#125;
  &lt;/ul&gt;
&lt;/nav&gt;
&#123;% endif %&#125;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Чтобы получить доступ к данным файла <b>main-nav.yml</b> нужно обратиться к переменной <b>site.data.main-nav</b>, где <b>site.data</b> это служебная конструкция, а <b>main-nav</b> имя файлы с данными. Первым делом мы проверяем существует ли данные со ссылками и если они существуют, то выводим навигационное меню.</p>

<p>Затем мы подключаем шаблон <b>navigation-item.html</b>, который выводит ссылки навигации. В данный шаблон через пользовательскую переменную <b>items</b> мы передаем содержимое файла <b>main-nav.yml</b>.</p>

<p>Содержимое файла <b>navigation-item.html</b> будет следующим.</p>

{% capture code %}
&#123;% for item in include.items %&#125;
&#123;% assign url = page.url | replace: '/index.html', '' %&#125;
&lt;li class="navigation__item &#123;% if item.url == url %&#125;navigation__item--active&#123;% endif %&#125;"&gt;
  &lt;a class="navigation__link" href="&#123;&#123; site.baseurl&#125;&#125;&#123;&#123; item.url &#125;&#125;"&gt;&#123;&#123; item.title &#125;&#125;&lt;/a&gt;
  &#123;% if item.links %&#125;
  &lt;ul class="navigation__sub-list"&gt;
    &#123;% include navigation-item.html items=item.links %&#125;
  &lt;/ul&gt;
  &#123;% endif %&#125;
&lt;/li&gt;
&#123;% endfor %&#125;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Для того чтобы внутри файла <b>navigation-item.html</b> получить переданные ссылки необходимо обратиться к пользовательской переменной <b>items</b> через конструкцию <b>include.items</b>, где <b>include</b> это служебное слово, а <b>items</b> это имя переменной которое мы сами дали в файле <b>navigation.html</b>.</p>

<p>В примере выше мы в цикле проходимся по каждой ссылке и выводи ее данные такие как <b>title</b>, <b>url</b>. Если пункт ссылки содержит вложенность <b>links</b>, то мы подключаем файл <b>navigation-item.html</b> передавая внутрь его вложенные ссылки. Происходит рекурсия при которой файл внутри себя подключает сам себя. И так до тех пор, пока не будут выведены все вложенные ссылки.</p>

<p>Так же идет сравнение активной ссылки в браузере, с ссылкой текущего пункта меню <b>&#123;% if item.url == url %&#125;</b>, если они равны происходит присваивание класса <b>navigation__item--active</b>, чтобы по особенному можно было стилизовать активный пункт меню.</p>

<h3>Шаблон _base.html</h3>

<p>Мы успешно создали включаемую область на страницу в виде навигации с использованием пользовательских данных. Теперь осталось лишь отобразить навигацию на странице. Для этого откроем файл <b>_layouts/base.html</b> и в шапку сайта подключим навигацию.</p>

{% capture code %}
---
layout: default
---

&#123;% contentfor header %&#125;
&lt;header&gt;
  &#123;% include navigation.html %&#125;
&lt;/header&gt;
&#123;% endcontentfor %&#125;

&#123;% contentfor content %&#125;
  &#123;&#123; content &#125;&#125;
&#123;% endcontentfor %&#125;

&#123;% contentfor script %&#125;
&lt;script&gt;
  console.log('Test')
&lt;/script&gt;
&#123;% endcontentfor %&#125;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Зайдем на главную страницу сайта, мы должны увидеть навигационное меню со всеми, указанными ссылками в файле <b>main-nav.yml</b>. Теперь мы можем очень легко и удобно администрировать навигационное меню, добавляя либо удаляя ссылки не затрагивая при этом саму верстку.</p>

<figure>
  {% include component/picture.html fancybox='true' slug=page.slug img='img-2.jpg' type='original' alt='Вид навигации на главной странице' %}
  <figcaption>Должны увидеть навигационное меню со всеми, указанными ссылками в файле <b>main-nav.yml</b>.</figcaption>
</figure>

<h2 id="assets"><span class="attention">Ресурсы</span> проекта</h2>

<p>Какой сайт обходится без стилей, скриптов и прочих ресурсов. В этом разделе создадим соответствующие разделы и подключим вспомогательные ресурсы.</p>

<p>По умолчанию <b>Jekyll</b> не умеет работать с <b>sass/scss</b> стилями, для этого необходимо установить соответствующее расширение.</p>

<h3>Расширение jekyll-sass-converter</h3>

<p>Откроем файл <b>Gemfile</b> и добавим в группу плагинов расширение <b>jekyll-sass-converter</b>. Для более детальной настройки ознакомьтесь с <a href="https://github.com/jekyll/jekyll-sass-converter" target="_blank" rel="nofollow">официальной документацией</a>.</p>

{% capture code %}
# Sass/Scss конвертер
# https://github.com/jekyll/jekyll-sass-converter
gem 'jekyll-sass-converter'
{% endcapture %}
{% include component/code.html lang='Gemfile' content=code %}

<p>Установим новое расширение <b>jekyll-sass-converter</b>.</p>

{% include component/code.html lang='bash' content='bundle install' %}

<p>После установки расширения настроим его отредактировав файл <b>_config.yml</b>.</p>

{% capture code %}
sass:
  sass_dir: _scss
  style: compressed
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<ul>
  <li><b>sass_dir</b> - название каталога с scss стилями</li>
  <li><b>style</b> - параметр сжатия стилей</li>
</ul>

<h3>Иерархия файлов</h3>

<p>Далее создадим два каталога <b>_scss</b> для стилей и <b>assets</b> для остальных файлов, такие как шрифты, картинки, скрипты и прочее.</p>

<p>Внутри каталога <b>_scss</b> продублируем иерархию файлов и их содержимое, основываясь на описанной ранее статье <a href="{{ site.baseurl }}/blog/2023-08-29-mnogofunkcionalnaya-gulp-sborka-dlya-produktivnoj-verstki-s-ispolzovaniem-pug-shablonizatora-frontend.html#task-styles" target="_blank">создание gulp сборки</a>. За некоторым исключением, файлы <b>main.scss</b> и <b>critical.scss</b> нужно будет разместить в каталоге <b>assets/css</b> если этого каталога нет создаем.</p>

{% capture code %}
./_scss
├── core
│    ├── base
│    │     ├── _base.scss
│    │     ├── _container.scss
│    │     └── _fonts.scss
│    └── helpers
│        ├── _functions.scss
│        ├── _mixins.scss
│        └── _variables.scss
└── scaffolds
    ├── components
    │    └── _button.scss
    └── sections
        └── _browser-upgrade.scss

./assets
└── css
  ├── main.scss
  └── critical.scss
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Если не понятно содержимое файлов ознакомьтесь с <a href="https://github.com/eliofery/gulp-template/tree/main/src/scss" target="_blank" rel="nofollow">исходным кодом</a> <b>Gulp борки</b>.</p>

<h3>Инициализция NPM</h3>

<p>Инициализируем <b>npm</b> для того, чтобы можно было использовать различные сторонние решения например <b>normalize.css
</b>.</p>

{% include component/code.html lang='bash' content='npm init -y' %}

<p>Установим <b>normalize.css</b>.</p>

{% include component/code.html lang='bash' content='npm i -D normalize.css' %}

<h3>Содержимое основных файлов стилей</h3>

<p>Содержимое файла <b>main.scss</b>.</p>

{% capture code %}
---
---
@import "core/helpers/functions";
@import "core/helpers/variables";
@import "core/helpers/mixins";

@import "core/base/fonts";

@import "scaffolds/components/button";

@import "scaffolds/sections/browser-upgrade";
{% endcapture %}
{% include component/code.html lang='scss' content=code %}

<p>Содержимое файла <b>critical.scss</b>.</p>

{% capture code %}
---
---
@import "core/helpers/functions";
@import "core/helpers/variables";
@import "core/helpers/mixins";

@import "../../node_modules/normalize.css/normalize";

@import "core/base/base";
@import "core/base/container";

//@import "scaffolds/components/name";

//@import "scaffolds/sections/name";
{% endcapture %}
{% include component/code.html lang='scss' content=code %}

<p>Обратите внимание, что в файлах <b>main.scss</b> и <b>critical.scss</b> присутствует разделитель <b>--- ---</b>, в данном случае он не содержит в себе переменные и необходим лишь для того, чтобы <b>Jekyll</b> понял что данный файл является основным и собрал его.</p>

<p>Запустим проект в режиме разработки.</p>

{% include component/code.html lang='scss' content='bundle exec jekyll serve' %}

<p>Откроем каталог <b>_site</b> который содержит собранный проект и зайдем в каталог <b>assets/css</b>. Как можно увидеть в каталоге содержатся два собранных файла <b>css</b>, которые теперь мы можем подключить на страницы.</p>

<h3>Подключение стилей на страницах</h3>

<p>Так как критические стили <b>critical.css</b> нужно будет размещать <b>inline</b> внутрь тега <b>&lt;style&gt;</b> хорошо было бы, чтобы его содержимое автоматически выносилось в этот тег. Для подключения одного файла внутрь другого мы уже знаем используется конструкция <b>&#123;% include %&#125;</b>, но она не умеет подключать файлы, находящиеся за пределами каталога <b>_includes</b>, а критические стили у нас за пределами этого каталога.</p>

<p>Чтобы каждый раз вручную не переносить файл <b>critical.css</b> из каталога <b>_site/assets/css</b> в каталог <b>includes</b>, чтобы потом его подключить. Мы добавим в наш <b>Jekyll</b> шаблон пару плагинов.</p>

<p>Нам понадобится <a href="https://github.com/michaelx/jekyll_file_exists" target="_blank" rel="nofollow">плагин file_exists</a>, который проверят файл на существование. И <a href="https://stackoverflow.com/a/75420946" target="_blank" rel="nofollow">плагин root_include</a>, который подключает файлы за пределами каталога <b>_includes</b>.</p>

<p>В корне шаблона создадим каталог <b>_plugins</b> и внутри данного каталога создаем два файла: <b>file_exists.rb</b> и <b>include_absolute.rb</b>.</p>

<p>Содержимое файла <b>file_exists.rb</b>.</p>

{% capture code %}
module Jekyll
    class FileExistsTag &lt; Liquid::Tag

        def initialize(tag_name, path, tokens)
            super
            @path = path
        end

        def render(context)
            # Pipe parameter through Liquid to make additional replacements possible
            url = Liquid::Template.parse(@path).render context

            # Adds the site source, so that it also works with a custom one
            site_source = context.registers[:site].config['source']
            file_path = site_source + '/' + url

            # Check if file exists (returns true or false)
            "#&#123;File.exist?(file_path.strip!)&#125;"
        end
    end
end

Liquid::Template.register_tag('file_exists', Jekyll::FileExistsTag)
{% endcapture %}
{% include component/code.html lang='rb' content=code %}

<p>Содержимое файла <b>include_absolute.rb</b>.</p>

{% capture code %}
class RootInclude &lt; Liquid::Tag
  def initialize(_tag_name, markup, _parse_context)
    super
    @markup = markup.strip
  end

  def render(context)
    expanded_path = Liquid::Template.parse(@markup).render(context)
    root_path = File.expand_path(context.registers[:site].config['source'])
    final_path = File.join(root_path, expanded_path)
    read_file(final_path, context)
  end

  def read_file(path, context)
    file_read_opts = context.registers[:site].file_read_opts
    File.read(path, **file_read_opts)
  end
end

Liquid::Template.register_tag('root_include', RootInclude)
{% endcapture %}
{% include component/code.html lang='rb' content=code %}

<p>Чтобы подключить стили откроем файл <b>_layouts/default.html</b> и ниже тега <b>&lt;base&gt;</b> добавим.</p>

{% capture code %}
&lt;!-- Критические стили   --&gt;
&#123;% assign path = '_site/assets/css/critical.css' %&#125;
&#123;% capture fileExists %&#125;&#123;% file_exists &#123;&#123; path &#125;&#125; %&#125;&#123;% endcapture %&#125;
&#123;% if fileExists == 'true' %&#125;
&#123;% capture critical %&#125;&#123;% root_include &#123;&#123; path &#125;&#125; %&#125;&#123;% endcapture %&#125;
&lt;style&gt;&#123;&#123; critical | scssify &#125;&#125;&lt;/style&gt;
&#123;% endif %&#125;

&lt;!-- Стили --&gt;
&lt;link rel="preload" as="style" href="&#123;&#123; '/assets/css/style.css?v=' | relative_url &#125;&#125;&#123;&#123; site.version | default: '0.0.1' &#125;&#125;" onload="this.rel='stylesheet'"&gt;
&lt;noscript&gt;&lt;link rel="stylesheet" href="&#123;&#123; '/assets/css/style.css?v=' | relative_url &#125;&#125;&#123;&#123; site.version | default: '0.0.1' &#125;&#125;"&gt;&lt;/noscript&gt;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Здесь мы проверяем существования файла по пути <b>_site/assets/css/critical.css</b>, если файл существует то мы создаем переменную <b>critical</b> в которую помещаем его содержимое. После чего выводим это содержимое на странице, прогнав его через фильтр минификации <b>scssify</b>.</p>

<p>Далее стандартным способом подключаем стили прогнав путь до файла через фильтр <b>relative_url</b>, который преобразует абсолютный <b>url</b> в относительный. Конструкция <b>onload="this.rel='stylesheet'"</b> позволит загрузить стили после загрузки всей страницы, что положительно сказывается на <b>Page Speed</b> показателях.</p>

<p>В терминале выйдем из режима разработки, нажав клавиши <kbd>Ctrl + C</kbd>. Удалим каталог <b>_site</b>, чтобы проверить успешно ли собирается проект и правильно ли внедряются критические стили. Если мы сейчас просто запустим команду работы над проектом в режиме разработки, то при сборке шаблона критические стили не подключатся, так как файл <b>critical.css</b> создается позже чем собираются <b>html</b> страницы.</p>

<p>Чтобы исправить этот нюанс, необходимо прежде собрать проект, а уже потом запускать режим разработки. Так же обратите внимание на новую опцию <b>--livereload</b>, благодаря нее браузер будет автоматически обновляться при изменении файлов шаблона.</p>

{% include component/code.html lang='bash' content='jekyll build && bundle exec jekyll serve --livereload' %}

<p>Обновим главную страницу и откроем исходный код в браузере. Как видим критические стили минифицированы и отображаются внутри тега <b>&lt;style&gt;</b>. Более того если мы изменим стили в <b>scss</b> файлах изменения автоматически применятся на странице и мы увидим обновленный вид.</p>

<figure>
  {% include component/picture.html fancybox='true' slug=page.slug img='img-3.jpg' type='original' alt='Исходный код главной страницы' %}
  <figcaption>Обновим главную страницу и откроем исходный код в браузере.</figcaption>
</figure>

<h3>Остальные ресурсы Assets</h3>

<p>Внутри каталога <b>assets</b> создайте каталоги:</p>

<ul>
  <li><b>favicons</b> - фавиконки</li>
  <li><b>fonts</b> - шрифты</li>
  <li><b>icons</b> - svg иконки, черно-белые и цветные</li>
  <li><b>images</b> - картинки</li>
  <li><b>js</b> - javascript скрипты</li>
</ul>

<p>Должна получиться примерно следующая структура. Примерную структуру и содержимое файлов можно <a href="https://github.com/eliofery/gulp-template/tree/main/src/assets" target="_blank" rel="nofollow">подсмотреть здесь</a>.</p>

{% capture code %}
./assets/
├── css
     ├── critical.scss
     └── style.scss
├── favicons
├── fonts
├── icons
├── images
└── js
    └── main.js
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Создадим файл <b>assets/js/main.js</b> и подключим его на странице, изменив содержимое файла <b>_layouts/base.html</b>.</p>

{% capture code %}
&#123;% contentfor script %&#125;
&lt;script src="&#123;&#123; '/assets/js/main.js?v=' | relative_url &#125;&#125;&#123;&#123; site.version | default: '0.0.1' &#125;&#125;" type="module"&gt;&lt;/script&gt;
&#123;% endcontentfor %&#125;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Раздел получился довольно большим, местами тяжелым. Важно понимать, что это лишь пример один из всевозможных вариантов, вы вправе создавать и использовать только те каталоги которые будете использовать. Моя задача лишь показать некоторый пример как это может выглядеть, а ваша задача уловить суть и сделать, так как вам надо.</p>

<h3>Highlight расширение</h3>

<p>Необязательный раздел, некоторое дополнение к теме о стилях. Если открыть файл статьи, который <b>Jekyll</b> создал по умолчанию, то можно увидеть следующую конструкцию.</p>

{% capture code %}
&#123;% highlight ruby %&#125;
def print_hi(name)
  puts "Hi, #&#123;name&#125;"
end
print_hi('Tom')
#=> prints 'Hi, Tom' to STDOUT.
&#123;% endhighlight %&#125;
{% endcapture %}
{% include component/code.html lang='md' content=code %}

<p>Это обертка, чтобы выводить код и т.п. в красивом оформленном виде, с подсветкой синтаксиса. Примерно как это выглядит на данном сайте. Данная функциональность по умолчанию включена в <b>Jekyll</b> только не имеет стилей. Для того чтобы ей придать стилевой оформление установим и настроим некоторые расширения.</p>

<p>Откроем <b>Gemfile</b> и добавим в группу плагинов новые расширения <b>kramdown</b> и <b>rouge</b>.</p>

{% capture code %}
# Hightlight
# https://jun711.github.io/web/how-to-highlight-code-on-a-Jekyll-site-syntax-highlighting/
# https://bnhr.xyz/2017/03/25/add-syntax-highlighting-to-your-jekyll-site-with-rouge.html
# rougify help style
# rougify style monokai > _sass/scaffolds/components/_syntax.scss
gem "kramdown"
gem "rouge"
{% endcapture %}
{% include component/code.html lang='Gemfile' content=code %}

<p>Установим новые расширения.</p>

{% include component/code.html lang='bash' content='bundle install' %}

<p>Откроем файл <b>_config.yml</b> и ниже конструкции <b>plugins</b> добавим настройки для расширений.</p>

{% capture code %}
# Подсветка синтаксиса
markdown: kramdown
kramdown:
  input: GFM
  syntax_highlighter: rouge
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<p>Посмотрим доступные стили для подсветки синтаксиса кода. Для этого в терминале введем команду.</p>

{% include component/code.html lang='bash' content='rougify help style' %}

<p>Появится следующий перечень стилей.</p>

<pre><code>available themes:
  base16, base16.dark, base16.light, base16.monokai, base16.monokai.dark,
  base16.monokai.light, base16.solarized, base16.solarized.dark,
  base16.solarized.light, bw, colorful, github, github.dark, github.light,
  gruvbox, gruvbox.dark, gruvbox.light, igorpro, magritte, molokai, monokai,
  monokai.sublime, pastie, thankful_eyes, tulip</code></pre>

<p>Выберем любой из них и установим.</p>

{% include component/code.html lang='bash' content='rougify style monokai > ./_scss/scaffolds/components/_hightlight.scss' %}

<p>В указанном каталоге должен появиться файл <b>_hightlight.scss</b> со стилями, который будет содержать цветовое оформление в стиле <b>monokai</b>.</p>

<p>Перезапустим шаблон в режиме разработки.</p>

{% include component/code.html lang='bash' content='jekyll build && bundle exec jekyll serve --livereload' %}

<p>Теперь сгенерированный файл с стилями подключим к шаблону, для этого откроем файл <b>assets/css/style.scss</b> и добавим.</p>

{% capture code %}
---
---
@import "core/helpers/functions";
@import "core/helpers/variables";
@import "core/helpers/mixins";

@import "core/base/fonts";

@import "scaffolds/components/button";
@import "scaffolds/components/hightlight";

@import "scaffolds/sections/browser-upgrade";
{% endcapture %}
{% include component/code.html lang='scss' content=code %}

<p>Откроем статью созданную <b>Jekyll</b> по умолчанию у меня она располагается по ссылке <b>/jekyll/2023/09/03/welcome-to-jekyll.html</b> и увидим что выбранная цветовая схема успешно применилась.</p>

<figure>
  {% include component/picture.html fancybox='true' slug=page.slug img='img-4.jpg' type='original' alt='Оформление кода' %}
  <figcaption>Увидим что выбранная цветовая схема успешно применилась.</figcaption>
</figure>

<h2 id="seo"><span class="attention">Seo</span> оптимизация</h2>

<p>В этом разделе рассмотрим <b>Seo</b> оптимизацию, добавим <b>Open Graph</b>, <b>Twitter Cards</b>, <b>Google Analytic</b>, <b>Yandex Metrika</b> и т.п.</p>

<h3>Seo расширения</h3>

<p>Откроем файл <b>Gemfile</b> и добавим в группу плагинов расширение <b>jekyll-seo-tag</b>. Для более детальной настройки ознакомьтесь с <a href="https://github.com/jekyll/jekyll-seo-tag" target="_blank" rel="nofollow">официальной документацией</a>.</p>

{% capture code %}
# SEO
# https://github.com/jekyll/jekyll-seo-tag/blob/master/docs/installation.md
gem "jekyll-seo-tag"
{% endcapture %}
{% include component/code.html lang='Gemfile' content=code %}

<p>Установим новое расширение <b>jekyll-seo-tag</b>.</p>

{% include component/code.html lang='bash' content='bundle install' %}

<p>После установки расширения настроим его отредактировав файл <b>_config.yml</b>.</p>

{% capture code %}
plugins:
  - jekyll-seo-tag
  - jekyll-feed
  - jekyll-sitemap
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<p>Создадим файл <b>head.html</b> внутри каталога <b>_includes</b>. Теперь откроем файл <b>_layouts/default.html</b> и вынесем все содержимое тега <b>&lt;head&gt;</b> в созданный файл <b>head.html</b>.</p>

{% capture code %}
&lt;meta charset="utf-8"&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;

&lt;title&gt;&#123;&#123; page.title &#125;&#125;&lt;/title&gt;

&lt;base href="&#123;&#123; site.baseurl &#125;&#125;"&gt;

&lt;!-- Критические стили   --&gt;
&#123;% assign path = '_site/assets/css/critical.css' %&#125;
&#123;% capture fileExists %&#125;&#123;% file_exists &#123;&#123; path &#125;&#125; %&#125;&#123;% endcapture %&#125;
&#123;% if fileExists == 'true' %&#125;
&#123;% capture critical %&#125;&#123;% root_include &#123;&#123; path &#125;&#125; %&#125;&#123;% endcapture %&#125;
&lt;style&gt;&#123;&#123; critical | scssify &#125;&#125;&lt;/style&gt;
&#123;% endif %&#125;

&lt;!-- Стили --&gt;
&lt;link rel="preload" as="style" href="&#123;&#123; '/assets/css/style.css?v=' | relative_url &#125;&#125;&#123;&#123; site.version | default: '0.0.1' &#125;&#125;" onload="this.rel='stylesheet'"&gt;
&lt;noscript&gt;&lt;link rel="stylesheet" href="&#123;&#123; '/assets/css/style.css?v=' | relative_url &#125;&#125;&#123;&#123; site.version | default: '0.0.1' &#125;&#125;"&gt;&lt;/noscript&gt;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>В файле <b>_layouts/default.html</b> подключаем <b>head.html</b>.</p>

{% capture code %}
&lt;html class="no-js" lang="&#123;&#123; page.lang | default: site.lang | default: 'ru' &#125;&#125;"&gt;
&lt;head&gt;
  &#123;% include head.html %&#125;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="layout"&gt;
  &#123;% contentblock header %&#125;

  &lt;main class="layout__main"&gt;
    &#123;% contentblock content %&#125;
  &lt;/main&gt;

  &#123;% contentblock footer %&#125;
&lt;/div&gt;

&#123;% contentblock script %&#125;
&lt;/body&gt;
&lt;/html&gt;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Теперь базовый шаблон не содержит ни чего лишнего и далее мы можем акцентироваться на наполнении файла <b>head.html</b> прописывая в него различные конструкции.</p>

<p>Подключим <b>Seo</b> расширения в файл <b>head.html</b> сразу после стилей.</p>

{% capture code %}
&#123;% seo title=false %&#125;
&#123;% feed_meta %&#125;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<ul>
  <li><b>seo</b> - подключит <b>Open Graph</b>, <b>Twitter Cards</b>, мета информацию <b>description</b>, <b>ld+json</b> в общем основные составляющие для seo продвижения</li>
  <li><b>feed_meta</b> - подключит ссылку на <b>RSS</b> ленту</li>
</ul>

<h3>Google и Yandex аналитика</h3>

<p>Откроем файл <b>_config.yml</b> и дабавим пользовательские переменные, которые будут хранить идентификаторы от <b>Google Analytic</b> и <b>Yandex Metrika</b>.</p>

{% capture code %}
google_analytics: UA-XXXXXXXXX-X
yandex_metrika: XXXXXX
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<p>В файле <b>head.html</b> ниже подключенных расширений подключим скрипты с <b>Google Analytic</b> и <b>Yandex Metrika</b>.</p>

{% capture code %}
&#123;% if jekyll.environment == 'production' and site.google_analytics and site.google_analytics != 'UA-XXXXXXXXX-X' %&#125;
&lt;!-- Google Analytics --&gt;
&lt;script&gt;
    if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) &#123;
        (function(i,s,o,g,r,a,m)&#123;i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()&#123;
            (i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        &#125;)(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', '&#123;&#123; site.google_analytics &#125;&#125;', 'auto');
        ga('send', 'pageview');
    &#125;
&lt;/script&gt;
&#123;% endif %&#125;

&#123;% if jekyll.environment == 'production' and site.yandex_metrika and site.yandex_metrika != 'XXXXXX' %&#125;
&lt;!-- Yandex Metrika --&gt;
&lt;script&gt;
    (function(m,e,t,r,i,k,a)&#123;m[i]=m[i]||function()&#123;(m[i].a=m[i].a||[]).push(arguments)&#125;;
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)&#125;)
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    ym('&#123;&#123; site.yandex_metrika &#125;&#125;', "init", &#123;&#125;);
&lt;/script&gt;
&#123;% endif %&#125;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Скрипты будут подключены по условию если в переменная среды <b>JEKYLL_ENV</b> будет равна значению <b>production</b>, а так же пользовательская переменная <b>site.google_analytics</b> которую мы создали в файле <b>_config.yml</b> должна существовать и не должна быть равна значению <b>UA-XXXXXXXXX-X</b> и <b>XXXXXX</b>.</p>

<p>Для того чтобы задать окружение для переменной среды, выполните в терминале команду.</p>

{% capture code %}
export JEKYLL_ENV=production

# Или

export JEKYLL_ENV=development
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Теперь когда получите идентификатор от какой-либо из этих платформ и пропишите его в файле <b>_config.yml</b>, при сборке шаблона должны подключится соответствующие скрипты.</p>

<h2 id="pagination"><span class="attention">Постраничная</span> пагинация</h2>

<p>В предыдущих разделах мы научились создавать статьи. При создании статьи мы определяли ее в определенную категорию через параметр <b>category</b> либо <b>categories</b>. Категории позволяют сгруппировать статьи и в дальнейшем показывать список тех статей чья категория была выбрана. И как правило при большом количестве материала принято разделять его на страницы, к примеру не более девяти статей на страницу.</p>

<h3>Расширение jekyll-paginate-v2</h3>

<p>В <b>Jekyll</b> подобный функционал возможен благодаря расширению <b>jekyll-paginate-v2</b>, давайте его установим. Добавим расширение в файл <b>Gemfile</b> в группу плагинов.</p>

{% capture code %}
# Пагинация
# https://github.com/sverrirs/jekyll-paginate-v2
gem "jekyll-paginate-v2"
{% endcapture %}
{% include component/code.html lang='Gemfile' content=code %}

<p>Более подробно с настройкой расширения <b>jekyll-paginate-v2</b> можно познакомиться на <a href="https://github.com/sverrirs/jekyll-paginate-v2" target="_blank" rel="nofollow">официальном сайте</a>.</p>

<p>Установим новое расширение <b>jekyll-paginate-v2</b>.</p>

{% include component/code.html lang='bash' content='bundle install' %}

<p>Далее откроем файл <b>_config.yml</b> и пропишем в нем следующие правила.</p>

{% capture code %}
# Подключение плагинов
plugins:
  - jekyll-seo-tag
  - jekyll-feed
  - jekyll-sitemap
  - jekyll-paginate-v2

# Пагинация
pagination:
  enabled: true
  per_page: 9
  permalink: '/page/:num/'
  title: ':title - Страница :num'
  limit: 0
  sort_field: 'date'
  sort_reverse: true
  trail:
    before: 2
    after: 2
{% endcapture %}
{% include component/code.html lang='yml' content=code %}

<ul>
  <li><b>enabled</b> - активировать пагинацию</li>
  <li><b>per_page</b> - количество статей на странице</li>
  <li><b>permalink</b> - вид ссылки на другие страницы</li>
  <li><b>title</b> - основной заголовок страницы</li>
  <li><b>limit</b> - максимальное количество страниц пагинации, 0 без лимита</li>
  <li><b>sort_field</b> - сортировка статей по дате</li>
  <li><b>sort_reverse</b> - сортировка статей от новых к старым</li>
  <li><b>trail</b> - задает количество страниц до и после текущей активной страницы, которые будут видны в пагинации</li>
</ul>

<h3>Шаблон blog.html</h3>

<p>В каталоге <b>_layouts</b> создадим файл <b>blog.html</b>, это будет шаблон для страниц со списком статей.</p>

{% capture code %}
---
layout: base
---
&lt;section class="blog"&gt;
  &lt;div class="container"&gt;
    &lt;h2 class="blog__title"&gt;&lt;span&gt;&#123;&#123; page.title &#125;&#125;&lt;/span&gt;&lt;/h2&gt;
    &lt;div class="blog__content"&gt;
      &#123;% if paginator.posts[0] %&#125;
      &lt;ul class="blog__list"&gt;
        &#123;% for post in paginator.posts %&#125;
        &lt;li class="blog__item"&gt;
          &lt;a class="blog__link" href="&#123;&#123; post.url &#125;&#125;"&gt;
            &lt;time class="blog__date" datetime="&#123;&#123; post.date | date: " %Y-%m-%dT%H:%M
            " &#125;&#125;"&gt;&#123;&#123; post.date | date: '%d.%m.%Y' &#125;&#125;&lt;/time&gt;
            &lt;h3 class="blog__title"&gt;&#123;&#123; post.title | markdownify | strip_html | truncatewords: 15 &#125;&#125;&lt;/h3&gt;
            &lt;div class="blog__desc"&gt;&#123;&#123; post.description | default: post.excerpt | markdownify | strip_html |
              truncatewords: 40 &#125;&#125;
            &lt;/div&gt;
          &lt;/a&gt;
        &lt;/li&gt;
        &#123;% endfor %&#125;
      &lt;/ul&gt;

      &#123;% if paginator.page_trail %&#125;
      &lt;ol class="blog__pagination"&gt;
        &#123;% if paginator.previous_page %&#125;
        &lt;li class="blog__pagination-item blog__pagination-item--prev"&gt;
          &lt;a class="blog__pagination-link" href="&#123;&#123; paginator.previous_page_path &#125;&#125;" aria-label="Предыдущее"&gt;
            &lt;--
          &lt;/a&gt;
        &lt;/li&gt;
        &#123;% endif %&#125;

        &#123;% for trail in paginator.page_trail %&#125;
        &#123;% if page.url == trail.path %&#125;
        &#123;% assign active = 'page-pagination__item--active' %&#125;
        &#123;% else %&#125;
        &#123;% assign active = '' %&#125;
        &#123;% endif %&#125;
        &lt;li class="blog__pagination-item &#123;&#123; active &#125;&#125;"&gt;
          &lt;a class="blog__pagination-link" href="&#123;&#123; trail.path | remove: 'index.html' &#125;&#125;"&gt;&#123;&#123; trail.num &#125;&#125;&lt;/a&gt;
        &lt;/li&gt;
        &#123;% endfor %&#125;

        &#123;% if paginator.next_page %&#125;
        &lt;li class="blog__pagination-item blog__pagination-item--next"&gt;
          &lt;a class="blog__pagination-link" href="&#123;&#123; paginator.next_page_path &#125;&#125;" aria-label="Следующее"&gt;
            --&gt;
          &lt;/a&gt;
        &lt;/li&gt;
        &#123;% endif %&#125;
      &lt;/ol&gt;
      &#123;% endif %&#125;
      &#123;% else %&#125;
      &lt;p&gt;Записей нет&lt;/p&gt;
      &#123;% endif %&#125;

      &lt;div class="blog__seo"&gt;
        &#123;&#123; content &#125;&#125;
      &lt;/div&gt;

    &lt;/div&gt;
  &lt;/div&gt;
&lt;/section&gt;
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Довольно большая разметка получилась, но здесь только самое главное.</p>

<ul>
  <li><b>&#123;&#123; page.title &#125;&#125;</b> - выводит заголовок страницы, страницу <b>blog</b> мы создадим ниже</li>
  <li><b>&#123;% if paginator.posts[0] %&#125;</b> - проверяет наличие статей, если статей нет выводим <b>&lt;p&gt;Записей нет&lt;/p&gt;</b></li>
  <li><b>&#123;% for post in paginator.posts %&#125;</b> - в цикле выводим каждую статью</li>
  <li><b>&#123;&#123; post.url &#125;&#125;</b> - ссылка на статью</li>
  <li><b>&#123;&#123; post.date | date: " %Y-%m-%dT%H:%M" &#125;&#125;</b> - дата создания статьи</li>
  <li><b>&#123;&#123; post.title | markdownify | strip_html | truncatewords: 15 &#125;&#125;</b> - заголовок статьи, здесь применяется ряд фильтров которые удаляют <b>markdown</b> и <b>html</b> разметку и обрезают предложение до 15 слов</li>
  <li><b>&#123;&#123; post.description | default: post.excerpt | markdownify | strip_html |
    truncatewords: 40 &#125;&#125;</b> - описание статьи, если у статьи не будет описания по умолчанию будет браться значения из краткого описания, здесь применяется ряд фильтров которые удаляют <b>markdown</b> и <b>html</b> разметку и обрезают предложение до 40 слов</li>
  <li><b>&#123;% if paginator.page_trail %&#125;</b> - проверка активна ли постраничная навигация</li>
  <li><b>&#123;% if paginator.previous_page %&#125;</b> - ссылка на предыдущую страницу пагинации</li>
  <li><b>&#123;% for trail in paginator.page_trail %&#125;</b> - перечисление доступных страниц пагинации</li>
  <li><b>&#123;% if paginator.next_page %&#125;</b> - ссылка на следующую страницу пагинации</li>
  <li><b>&#123;&#123; content &#125;&#125;</b> - выводит контентную часть страницы <b>blog</b> которую мы создадим ниже</li>
</ul>

<h3>Страница blog.html</h3>

<p>В каталоге <b>_pages</b> создадим файл <b>blog.html</b> со следующим содержимым.</p>

{% capture code %}
---
layout: blog
title: Блог
description: Статьи с рецептами
permalink: /blog
pagination:
  enabled: true
---

Описание страницы Блог
{% endcapture %}
{% include component/code.html lang='html' content=code %}

<p>Для проверки пагинации продублируем имеющуюся статью в каталоге <b>_posts</b> и в файле <b>_config.yml</b> изменим значение параметра <b>per_page</b> на 1. Чтобы выводилась одна статья на страницу и того мы должны будем увидеть пагинацию.</p>

<figure>
  {% include component/picture.html fancybox='true' slug=page.slug img='img-5.jpg' type='original' alt='Страница блог' %}
  <figcaption>Чтобы выводилась одна статья на страницу и того мы должны будем увидеть пагинацию.</figcaption>
</figure>

<h2 id="picture"><span class="attention">Изображения</span> на сайте</h2>

<p>Хорошо бы если каждая будь то статья, страница или коллекция имела изображение, некую миниатюру. В этом разделе мы создадим структуру для хранения картинок, установим ряд расширений которые позволят конвертировать формат картинки в <b>Webp</b>, создавать картинки различного разрешения и т.п.</p>

<h3>Расширение mini_magick</h3>

<p>Расширение <b>mini_magick</b> позволит изменять размер изображений в соответствии с пользовательскими настройками. Более детально с этим расширением можно познакомиться <a href="https://github.com/zroger/jekyll-minimagick" target="_blank" rel="nofollow">здесь</a> и <a href="https://github.com/zroger/jekyll-minimagick" target="_blank" rel="nofollow">здесь</a>.</p>

<p>Добавим расширение <b>mini_magick</b> в файл <b>Gemfile</b> в группу плагинов.</p>

{% capture code %}
# Обрезка и изменение размера изображений
# https://github.com/zroger/jekyll-minimagick
# https://github.com/MattKevan/Jekyll-MiniMagick-new
# https://www.kevan.tv/2016/10/17/automatic-image-resizing-with-jekyll-and-imagemagick/
gem "mini_magick"
{% endcapture %}
{% include component/code.html lang='Gemfile' content=code %}

<p>Далее создадим в каталоге <b>_plugins</b> файл с названием <b>jekyll_minimagick.rb</b> и вставим в него содержимое <a href="https://github.com/MattKevan/Jekyll-MiniMagick-new/blob/master/jekyll_minimagick.rb" target="_blank" rel="nofollow"> этого файла</a>. В данный файл я внес небольшие свои правки для того чтобы в будущем не было проблем с файлами <b>webp</b>. Содержимое файла <b>jekyll_minimagick.rb</b> должно получиться таким.</p>

{% capture code %}
require 'mini_magick'

module Jekyll
  module JekyllMinimagick

    class GeneratedImageFile &lt; Jekyll::StaticFile
      # Initialize a new GeneratedImage.
      #   +site+ is the Site
      #   +base+ is the String path to the &lt;source&gt;
      #   +dir+ is the String path between &lt;source&gt; and the file
      #   +name+ is the String filename of the file
      #   +preset+ is the Preset hash from the config.
      #
      # Returns &lt;GeneratedImageFile&gt;
      def initialize(site, base, dir, name, preset)
        @site = site
        @base = base
        @dir  = dir
        @name = name
        @dst_dir = preset.delete('destination')
        @src_dir = preset.delete('source')
        @commands = preset
        @relative_path = File.join(*[@dir, @name].compact)
        @extname = File.extname(@name)
      end

      # Obtains source file path by substituting the preset's source directory
      # for the destination directory.
      #
      # Returns source file path.
      def path
        File.join(@base, @dir.sub(@dst_dir, @src_dir), @name)
      end

      # Use MiniMagick to create a derivative image at the destination
      # specified (if the original is modified).
      #   +dest+ is the String path to the destination dir
      #
      # Returns false if the file was not modified since last time (no-op).
      def write(dest)
        dest_path = destination(dest)
        dest_path ['_site/'] = ''

#         puts dest_path

        return false if File.exist? dest_path and !modified?
        self.class.mtimes[path] = mtime

        FileUtils.mkdir_p(File.dirname(dest_path))
        image = ::MiniMagick::Image.open(path)
        image.combine_options do |c|
          @commands.each_pair do |command, arg|
            c.send command, arg
          end
        end
        image.write dest_path

        true
      end

    end

    class MiniMagickGenerator &lt; Generator
      safe true

      # Find all image files in the source directories of the presets specified
      # in the site config.  Add a GeneratedImageFile to the static_files stack
      # for later processing.
      def generate(site)
        return unless site.config['mini_magick']

        site.config['mini_magick'].each_pair do |name, preset|
          Dir.chdir preset['source'] do
           Dir.glob(File.join("**", "*.{png,jpg,jpeg,gif}")) do |source|
              site.static_files &lt;&lt; GeneratedImageFile.new(site, site.source, preset['destination'], source, preset.clone)
             end
          end
        end
      end
    end

  end
end
{% endcapture %}
{% include component/code.html lang='rb' content=code %}

<p>Устанавливаем расширение <b>mini_magick</b>.</p>

{% include component/code.html lang='bash' content='bundle install' %}

<p>Откроем файл <b>_config.yml</b> и пропишем следующие настройки.</p>

{% capture code %}
# Обрезка и изменение размера изображений
mini_magick:
  thumbnail:
    source: images/original
    destination: images/thumbnail
    resize: "530x390^"
    gravity: "center" # NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast
    extent: "530x390"
  recipe:
    source: images/original
    destination: images/recipe
    resize: "550x450^"
    gravity: "center"
    extent: "550x450"
  full:
    source: images/original
    destination: images/full
    resize: "1920x500^"
    gravity: "center"
    extent: "1920x500"
{% endcapture %}
{% include component/code.html lang='rb' content=code %}

<ul>
  <li><b>thumbnail / recipe / full</b> - различные варианты миниатюр, каждый вариант со своими настройками</li>
  <li><b>source</b> - источник оригинальной картинки</li>
  <li><b>destination</b> - источник картинки определенного варианта</li>
  <li><b>resize / extent</b> - новый размер картинки, знак ^ означает что картинка будет сохранять свои пропорции</li>
  <li><b>gravity</b> - какую часть картинки расширение будет стремиться сохранить при обрезке</li>
</ul>

<p>Можно добавлять сколько угодно форматов картинок, расширения будет автоматически их создавать на основе оригинальной картинки.</p>

<h3>Создание структуры для картинок</h3>

<p>Теперь в корне проекта создадим каталог <b>images</b>, внутри данного каталога создадим каталог где будут храниться оригинальные изображения <b>original</b>. Далее нужно повторить структуру каталога <b>_posts</b>. В общем у нас должно получиться следующее.</p>

{% capture code %}
./images/
├── original
│    └── 2023
└──      └── 09
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Для хранения картинок отдельной статьи нужно создать каталог для нее и назвать его так же как называется файл статьи, за исключением даты создания, указываем только имя и помещаем в этот каталог картинки. Например:</p>

{% capture code %}
./images/
├── original
│    └── 2023
        └── 09
            └── welcome-to-jekyll
                └── cover.jpg
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Запустим проект в режиме разработки.</p>

{% include component/code.html lang='bash' content='jekyll build && bundle exec jekyll serve --livereload' %}

<p>В каталоге <b>images</b> должны появиться каталоги с нашими настроенными в файле <b>_config.yml</b> типами изображений.</p>

{% capture code %}
./images/
├── full
├── original
├── recipe
└── thumbnail
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Все каталоги кроме <b>original</b> не нужны нам в репозитории потому добавим их в файл <b>.gitignore</b>.</p>

{% capture code %}
images/full
images/recipe
images/thumbnail
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Если открыть каталог <b>_site/images</b>, то мы увидим ту же самую структуру каталогов с картинками. Помимо стандартных картинок формата <b>jpg</b> и прочее должны так же появится картинки формата <b>webp</b>.</p>

<p>Теперь, чтобы вставить картинку на сайт, откроем статью и разместив в ней следующую разметку.</p>

{% capture code %}
&lt;picture&gt;
  &lt;source srcset="/images/thumbnail/2023/09/welcome-to-jekyll/cover.webp" type="image/webp"&gt;
  &lt;img src="/images/thumbnail/2023/09/welcome-to-jekyll/cover.jpg" alt=""&gt;
&lt;/picture&gt;
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<p>Здесь мы указали относительный путь до нужной картинки формата <b>thumbnail</b>, так же мы могли бы указать другой формат например <b>recipe</b>.</p>

{% capture code %}
&lt;picture&gt;
  &lt;source srcset="/images/recipe/2023/09/welcome-to-jekyll/cover.webp" type="image/webp"&gt;
  &lt;img src="/images/recipe/2023/09/welcome-to-jekyll/cover.jpg" alt=""&gt;
&lt;/picture&gt;
{% endcapture %}
{% include component/code.html lang='bash' content=code %}

<h2 id="end"><span class="attention">Подведем</span> итоги</h2>

<p>Мы проделали большую кропотливую работу, затронули все основные моменты. Конечно еще можно было много всего добавить, например поиск по сайту, svg спрайты, создать компоненты для удобной вставки тех же картинок и многое другое, лишь бы была фантазия.</p>

<p>Надеюсь данная статья хоть немного поможет вам разобраться с этим интересным инструментом под название <b>Jekyll</b>.</p>

<p>Я продолжу дальше работать над этим шаблоном доводя его до ума. Актуальная версия шаблона будет доступна в
  <a href="https://github.com/eliofery/jekyll-template" target="_blank" rel="nofollow">моем репозитории</a>. Надеюсь когда вы будете читать эти строки шаблон будет полностью готов и вы сможете подчеркнуть еще больше идей для себя.</p>
